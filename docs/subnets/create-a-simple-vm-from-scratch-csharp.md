# How to Build a Simple VM From Scratch using `C#`

This is part of a series of tutorials for building a Virtual Machine (VM):

- [Introduction to VMs](./introduction-to-vm.md)
- [How to Build a Simple Golang VM](./create-a-vm-timestampvm.md)
- [How to Build a Complex Golang VM](./create-a-vm-blobvm.md)
- [How to Build a Simple Rust VM](./create-a-simple-rust-vm.md)
- [How to Build a Simple VM From Scratch](./create-a-simple-vm-from-scratch.md)
- How to Build a Simple VM From Scratch using C# (this article)

## Introduction

This is a step by step guide on how to start creating a Subnet using C#. The end result is a
 _working but incomplete_ Subnet VM running on a local network.

It's a C# implementation of the previous guide
[how to create a Subnet from scratch](./create-a-simple-vm-from-scratch.md).

The source code corresponding to this guide is available on
[github](https://github.com/boulix3/subnet-from-scratch-csharp), and at the end
of each section, you will find the link to a branch representing the current
implementation.

## Pre-Requisites

This is for C# developers with little or no blockchain knowledge. This guide is
assuming you are using Linux, but it can probably work just as well on a mac, or
on windows using WSL2.

- [dotnet](https://dotnet.microsoft.com/en-us/download/dotnet) :
  You must follow the instructions to install .net to use the `dotnet` command.

Install useful dotnet tools in your project
_dotnet-grpc is a tool to manage Proto files easily, and avalanche .net CLI is a
tool to help you manage AvalancheGo binaries, and build and run your VMs
locally_

```sh
dotnet new tool-manifest
dotnet tool install dotnet-grpc
dotnet tool install avalanche
```

- [AvalancheGo](https://github.com/ava-labs/avalanchego/releases) :
  Extract the latest release in your ~/bin folder

- [avalanche-network-runner](https://github.com/ava-labs/avalanche-network-runner/releases) :
  Extract the latest release in your ~/bin folder

## Project Initialization

```sh
dotnet new grpc -n MySubnet
```

This will create a new project named MySubnet using the [dotnet grpc template](https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-7.0&tabs=visual-studio-code).

This project is a basic ASP.NET Core gRPC Server, with an example GreeterService
built from the `greet.proto` file. We will remove these as we clean-up.

### Add Avalanche Proto Files

We manage the Proto references files using `dotnet-grpc` instead of using `buf`,
because it is so well integrated into .net tooling.

Open the `src/MySubnet/MySubnet.csproj`, and add the following `ItemGroup` to
add the minimum required Proto references.

```xml
  <ItemGroup>
    <Protobuf Include="../protos/io/prometheus/client/metrics.proto" Link="Protos/metrics.proto" GrpcServices="None">
      <SourceUrl>
        https://raw.githubusercontent.com/prometheus/client_model/master/io/prometheus/client/metrics.proto</SourceUrl>
    </Protobuf>
    <Protobuf Include="../protos/vm.proto" Link="Protos/vm.proto" GrpcServices="Server">
      <SourceUrl>https://raw.githubusercontent.com/ava-labs/avalanchego/master/proto/vm/vm.proto</SourceUrl>
    </Protobuf>    
    <Protobuf Include="../protos/runtime.proto" Link="Protos/runtime.proto" GrpcServices="Client">
      <SourceUrl>
        https://raw.githubusercontent.com/ava-labs/avalanchego/master/proto/vm/runtime/runtime.proto
      </SourceUrl>
    </Protobuf>    
  </ItemGroup>
```

Download the references and build your project

```sh
dotnet dotnet-grpc refresh
dotnet build
```

These commands download the Proto files from the specified urls, and builds the
project to generate the appropriate C# classes. You can execute these commands
whenever there is a new version of the Proto files. 

### Cleanup

- Delete all unnecessary files that were generated by the `dotnet grpc template` :
  - settings files : `appsettings.*`
  - folders : `Service`, `Properties` and `Protos`
- In `Program.cs`, remove the GreeterService registration `app.MapGrpcService<GreeterService>();`.
- In `MySubnet.csproj`, remove the block containing the reference to the
  `greet.proto` file `<Protobuf Include="Protos\greet.proto" GrpcServices="Server"
  />`.

### Empty Proto Implementations

Create a folder named Avalanche which will contain the needed classes for
communication between our VM and AvalancheGo. In this folder, create these two
classes:

- `RuntimeClient.cs` is used to call AvalancheGo's runtime service. It uses the
  `RuntimeClient` class generated from the `runtime.proto` file.

```csharp
namespace MySubnet.Avalanche;
public class RuntimeClient
{
    private Vm.Runtime.Runtime.RuntimeClient _grpcClient;
    public RuntimeClient(Vm.Runtime.Runtime.RuntimeClient grpcClient)
    {
        _grpcClient = grpcClient;
    }
}
```

- `VmServer.cs` is the VM implementation called by AvalancheGo. It inherits the
  `VMBase` class generated from the `vm.proto` file. This is where we will need
  to implement the grpc service's methods.

```csharp
namespace MySubnet.Avalanche;
public class VmServer : Vm.VM.VMBase
{
}
```

We now have the basic structure of our project. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/project-initialization/src)

### Genesis File

We will need to provide a genesis file to initialize the VM, let's just create
an empty json file (`{}`) and name it genesis.json.

## Starting the Process

Avalanche will look in it's plugin folder (`~/.avalanchego/plugins/`) for a file
named with the VMId corresponding to the VM's name. You can get a VMId using
this [tool](https://avalanche-online-tools.web.app/).

For `MySubnet`, the corresponding VMId is `b7y7rNCYGFHBtRhrr5Y87KJML6MWVnx2MnLmnup6DpZafRpGr`.

To produce a single file binary, we need to modify `MySubnet.csproj` by adding
`<PublishSingleFile>true</PublishSingleFile><RuntimeIdentifier>linux-x64</RuntimeIdentifier>`
inside the main `<PropertyGroup>`.

Running `dotnet publish -o build` will produce a single binary :
`build/MySubnet`. That file needs to be in the plugins directory and named using
the VMId. `cp build/MySubnet
~/.avalanchego/plugins/b7y7rNCYGFHBtRhrr5Y87KJML6MWVnx2MnLmnup6DpZafRpGr` 

### Avalanche .Net CLI

Using the .Net tool is easier, it downloads AvalancheGo and
Avalanche-Network-Runner binaries and automates the process of building, and
starting a local network to try out your VM.

Initialize the tool using the `dotnet avalanche init` command. The prompt's
default values should be good. This will generate a file named
`avalanche.net.config`.

When the initialization is complete, we can run the project locally using the
`dotnet avalanche run` command.
The tool executes the following tasks using the information contained in the `avalanche.net.config`:

- If this is the first time it is run, it downloads AvalancheGo and
  Avalanche-network-runner in the `basePath` directory
- Build the project using the `vmBuildCommand`
- Copy the binary to `avalanchePluginsPath` and rename the file using the `VMId`
- Start a 5 node network using Avalanche-network-runner
- Register the Subnet and the VM

With our current implementation, this last step will fail of course, but we can
see in the console that our process has been started by AvalancheGo.

### Process Registration

While launching your binary, avalanche's go passes an environment variable
`AVALANCHE_VM_RUNTIME_ENGINE_ADDR` containing an url. We must use this url to initialize a
`vm.Runtime` client.
The `ProtocolVersion` constant matches the `supported plugin version` of the
[AvalancheGo release](https://github.com/ava-labs/AvalancheGo/releases).

```csharp
const int ProtocolVersion = 24;
// Get the Avalanche runtime grpc address from the environment variable. Fail fast if not defined.
var avalancheVmRuntimeEngineAddr
    = Environment.GetEnvironmentVariable("AVALANCHE_VM_RUNTIME_ENGINE_ADDR")
    ?? throw new ArgumentException("AVALANCHE_VM_RUNTIME_ENGINE_ADDR environment variable is null");
var globalSettings = new GlobalSettings(avalancheVmRuntimeEngineAddr, new(), ProtocolVersion);
```

The `Kestrel` WebServer listens on port 5000 by default. We use port `0`
to force it to get a random unused port.

```csharp
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenAnyIP(0, // Random unused port.
        endpointDefaults => { endpointDefaults.Protocols = HttpProtocols.Http2; });
});
```

Register the `VmServer` service, start the WebServer and register the VM using
the `RuntimeClient.Initialize` method.

```csharp
app.MapGrpcService<VmServer>();
await app.StartAsync(globalSettings.TokenSource.Token);
var runtimeClient = app.Services.GetRequiredService<RuntimeClient>();
runtimeClient.Initialize(app);
while (!globalSettings.TokenSource.IsCancellationRequested)
{
    await Task.Delay(1000); // Keep awake
}
```

The RuntimeClient must call Avalanche's 
[`vm.Runtime.InitializeRequest`](https://buf.build/ava-labs/avalanche/docs/main:vm.runtime#vm.runtime.InitializeRequest)
Grpc method. It requires the current WebServer address in the following format :
`host:port`, and the protocol version defined earlier. 

```csharp
public class RuntimeClient
{
    private readonly Vm.Runtime.Runtime.RuntimeClient _grpcClient;
    private readonly uint _protocolVersion;
    private readonly ILogger _logger;
    public RuntimeClient(GlobalSettings settings, ILogger<RuntimeClient> logger)
    {
        this._logger = logger;
        _grpcClient = new(GrpcChannel.ForAddress($"http://{settings.Url}"));
        _protocolVersion = settings.ProtocolVersion;
    }

    public void Initialize(WebApplication app)
    {
        var address = GetServerAddress(app);
        _logger.LogInformation("Calling Runtime.Initialize on {@address}", address);
        _grpcClient.Initialize(new Vm.Runtime.InitializeRequest
        {
            Addr = address,
            ProtocolVersion = _protocolVersion
        });
    }

    private static string GetServerAddress(WebApplication app)
    {
        var url = app.Urls.FirstOrDefault();
        if (url != null)
        {
            var port = GetPort(url);
            return $"localhost:{port}";
        }
        throw new Exception("Unable to get the WebServer's address");
    }

    private static int GetPort(string serverAddress)
    {
        var regex = "[0-9]+$";
        var match = Regex.Match(serverAddress, regex, RegexOptions.NonBacktracking);
        if (match.Success) return int.Parse(match.Value, CultureInfo.InvariantCulture);
        throw new Exception("Unable to extract port from url " + serverAddress);
    }
}
```

At this point, we have not yet implemented any methods of the
[`vm.VM`](https://buf.build/ava-labs/avalanche/docs/main:vm) Proto. Let's start
by implementing the first method,
[VM.Version](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.VM.Version). 

```csharp
    public override Task<VersionResponse> Version(Empty request, ServerCallContext context)
    {
        var version = Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "UndefinedVersion";
        _logger.LogInformation("VmServer.Version called => {version}", version);
        return Task.FromResult(new VersionResponse
        {
            Version = version
        });
    }
```

Execute `dotnet avalanche run` to try out the latest changes. By checking the
logs, the VM now registers correctly, and the `Version` method call is a
success. 

```log
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
[node2]       Executing endpoint 'gRPC - /vm.VM/Version'
[node2] info: MySubnet.Avalanche.VmServer[0]
[node2]       VmServer.Version called => 0.0.1.0
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
[node2]       Executed endpoint 'gRPC - /vm.VM/Version'
```

Since the `VmServer` class does not implement any other method, there are
errors, for example for the `Shutdown` call.

```log
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
[node2]       Executing endpoint 'gRPC - /vm.VM/Shutdown'
[node2] info: Grpc.AspNetCore.Server.ServerCallHandler[7]
[node2]       Error status code 'Unimplemented' with detail '' raised.
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
[node2]       Executed endpoint 'gRPC - /vm.VM/Shutdown'
```

We now have a valid binary started by AvalancheGo. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src)

## VM Initialization

In this section, we must implement the methods described in the corresponding
section of the 
[language-agnostic
documentation](./create-a-simple-vm-from-scratch.md#vm-initialization)

For now, we will ignore all the `blockchain` logic and only focus on
making sure the VM is correctly initialized by AvalancheGo. 

[VmServer.cs](https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/VmServer.cs)
inherits from `VmBase`, an abstract class automatically generated from the
`vm.proto` file we referenced in our project file, `MySubnet.csproj`. If we look
at `VmBase`'s content, we will see that it implements all the methods from the
Proto file, but throws an exception in the body : 
`throw new RpcException(new Status(StatusCode.Unimplemented, ""));`

Avalanche Ids must be 32 bytes long and the protobuf C# implementation uses the
`Google.Protobuf.ByteString` type. We will create an `Id` class to with
operators to convert from and to `ByteString`.

```csharp
    internal class Id
    {
        private readonly byte[] _bytes;
        private Id(byte[] bytes)
        {
            _bytes = bytes;
        }
        public bool IsValid => _bytes.Length == 32;
        public static implicit operator ByteString(Id id) => ByteString.CopyFrom(id._bytes);
        public static explicit operator Id(ByteString byteString) => new Id(byteString.ToByteArray());       
        public static Id Default = new Id(new byte[32]);
    }
```

For our VM initialization to be valid, we have to override those methods. For
now, we will return objects with these default values :

- Ids : `Id.Default` (32 bytes filled with zero)
- Err :
  [`Error.Unspecified`](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.Error) 
  to indicate that no error has occurred
- Other : filled with their default values


For example, here is the implementation of the Initialize method. 

```csharp
    public override Task<InitializeResponse> Initialize(InitializeRequest request, ServerCallContext context)
    {
        base.Initialize
        return Task.FromResult(new InitializeResponse()
        {
            Bytes = ByteString.Empty,
            Height = 0,
            LastAcceptedId = Id.Default,
            LastAcceptedParentId = Id.Default,
            Timestamp = Timestamp.FromDateTime(DateTime.UtcNow)
        });
    }
```

You can check-out the full [VmServer
implementation](https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/VmServer.cs).
This implementation is minimal, we only want our VM to register and initialize
correctly with AvalancheGo.

Execute `dotnet avalanche run` to try out the latest changes. After a few
minutes, we can see that the initialization process has ended without errors.

Our VM is now correctly initialized and started by AvalancheGo. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/vm-initialization/src)

## Building Blocks

We will now implement a very simple blockchain. For the sake of keeping this
guide as simple as possible, our blockchain will have the following
characteristics : 

- Transactions are not cryptographically signed
- Users are defined by their name, no public key
- Block contains balances
- Transfer transactions only
- Genesis contains two users: Alice and Bob

We will create the `AppSenderClient`, `MessengerClient`, and `HttpServer`
classes from the corresponding Proto interfaces.
We will also create the `Blockchain` class to manage our blocks.

We must also register them to be able to inject them using the dependency
injection provider.

```csharp
builder.Services.AddScoped<AppSenderClient>();
builder.Services.AddScoped<MessengerClient>();
builder.Services.AddSingleton<BlockChain>();
```

### Blockchain Data

To keep things simple, we only need to keep track of blocks and transaction.
The [Blockchain
class](https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs)
will hold the data and will be registered as a singleton. 

```csharp
    public ConcurrentDictionary<string, Block> FinalBlocks { get; } = new();
    public ConcurrentDictionary<string, Block> PendingBlocks { get; } = new();
    public ConcurrentDictionary<string, Transaction> TransactionPool { get; } = new();
    public Block? PreferredBlock { get; set; }
    public string LatestBlockHash { get; set; } = Id.Default.ToString();
    public Block LatestBlock => FinalBlocks[LatestBlockHash];
```

The `Block` class holds the following data:Balances, Transactions, Height, Hash,
and ParentHash. 

```csharp
public record Block(Dictionary<string, ulong> Balances, Transaction[] Transactions, ulong Height, long Timestamp,
    string Hash, string ParentHash)
{
    public static Block Create(Dictionary<string, ulong> balances, Transaction[] transactions, ulong height,
        string parentHash)
    {
        var block = new Block(balances, transactions,
            height, DateTimeOffset.Now.ToUnixTimeMilliseconds(),
            string.Empty, parentHash);
        return block with
        {
            Hash = block.HashBlock()
        };
    }

    internal string HashBlock()
    {
        var hashLessBlock = this with
        {
            Hash = Id.Default.ToString()
        };
        return hashLessBlock.HashObject();
    }
}
```

The `Transaction` class holds the following data:From, To, Amount, Status
and Hash.

```csharp
public record Transaction(string From, string To, ulong Amount, TransactionStatus Status, string Hash)
{
    public static Transaction Create(string from, string to, ulong amount)
    {
        var tx = new Transaction(from, to, amount, TransactionStatus.Pending, string.Empty);
        return tx with
        {
            Hash = tx.HashTransaction()
        };
    }

    internal string HashTransaction()
    {
        var hashLessTx = this with
        {
            Hash = Id.Default.ToString()
        };
        return hashLessTx.HashObject();
    }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum TransactionStatus
{
    Pending,
    Accepted,
    Rejected
}
```

AvalancheGo's Proto interfaces, when managing data expects a byte array, which
corresponds to a
[ByteString](https://protobuf.dev/reference/csharp/api-docs/class/google/protobuf/byte-string)
on the classes generated from the Proto. We will use a non-performant but easy
to use converter that serializes the object to `json` and then transform it to a
`ByteString` using `UTF8` encoding.

```csharp
    public static string SerializeJson(this object? item)
    {
        return item == null
            ? "null"
            : JsonSerializer.Serialize(item, DefaultJsonOptions);
    }

    public static T? DeserializeJson<T>(this string json)
    {
        return JsonSerializer.Deserialize<T>(json, DefaultJsonOptions);
    }

    public static ByteString SerializeJsonByteString(this object? item)
    {
        return ByteString.CopyFromUtf8(item.SerializeJson());
    }

    public static T? DeserializeJsonByteString<T>(this ByteString byteString)
    {
        return byteString.ToStringUtf8().DeserializeJson<T>();
    }
```

### JSON-RPC

To enable your json-RPC endpoint, you must implement the HandleSimple method of
the [`Http`](https://buf.build/ava-labs/avalanche/docs/main:http) interface. 


The `HandleSimple` method contains the original request. The request body is
most likely a `Json-RPC 2.0` object.

```csharp
    public override Task<HandleSimpleHTTPResponse> HandleSimple(HandleSimpleHTTPRequest request,
        ServerCallContext context)
    {
        try
        {
            if (request.Method.Equals("POST", StringComparison.InvariantCultureIgnoreCase))
            {
                var jsonBody = request.Body.ToStringUtf8();
                _logger.LogInformation("Http request body : {jsonBody}", jsonBody);
                var rpcRequest = jsonBody.DeserializeJson<JsonRpcRequest>();
                if (rpcRequest != null) return HandleJsonRpcRequest(rpcRequest);
            }
        }
        catch (Exception e)
        {
            return Task.FromResult(BuildResponse(null, null,
                new JsonRpcError("ERROR", "Error : " + e.Message, null)));
        }

        return Task.FromResult(BuildResponse(null, null,
            new JsonRpcError("INVALID_REQUEST", "Invalid Json-RPC request", null)));
    }
```

To keep things simple, we will support 3 methods : 

- `Transfer` to create a simple send transaction.
- `LatestBlock` to get the last accepted block.
- `BlockchainState` to get all our blockchain data (finalized blocks, pending
  blocks, and transaction pool).

```csharp
    private async Task<HandleSimpleHTTPResponse> HandleJsonRpcRequest(JsonRpcRequest rpcRequest)
    {
        return rpcRequest.Method switch
        {
            "Transfer" => await Transfer(rpcRequest),
            "LatestBlock" => GetLatestBlock(rpcRequest),
            "BlockchainState" => GetBlockchainState(rpcRequest),
            _ => BuildResponse(rpcRequest, null,
                new JsonRpcError("NOT_IMPLEMENTED", $"Method {rpcRequest.Method} is not implemented", null))
        };
    }
```

Let's see the implementation of the `Transfer` method. We must deserialize the
JSON-RPC `params` field and 

```csharp
    private async Task<HandleSimpleHTTPResponse> Transfer(JsonRpcRequest rpcRequest)
    {
        var transaction = rpcRequest.DeserializeParameters<Transaction>();
        if (transaction == null || transaction.From == null || transaction.To == null)
            return BuildResponse(rpcRequest, null,
                new JsonRpcError("INVALID_TRANSACTION", "Unable to parse transaction " + rpcRequest.Parameters, null));
        transaction = transaction with
        {
            Hash = transaction.HashObject()
        };
        _blockchain.AddPendingTransaction(transaction);
        await _appSender.GossipTransaction(transaction);
        return BuildResponse(rpcRequest, transaction, null);
    }
```

### Transaction

The only supported transactions are simple transfers. For example, here is a
transaction where Bob sends 100 coins to Alice :

```json
{
  "from":"Bob",
  "to":"Alice",
  "amount":100
}
```

The transactions can have these statuses :

- Pending : In the transaction pool.
- Accepted : Valid transaction included in a block.
- Rejected : Invalid transaction included in a block.

Whenever a transaction is received, it is added to the transaction pool and
sent to the other nodes by calling the `AppSender.SendAppGossip` method.
The `_appsender` and `_blockchain` classes are injected in this class.

```csharp
    private async Task<HandleSimpleHTTPResponse> Transfer(JsonRpcRequest rpcRequest)
    {
        var transaction = rpcRequest.DeserializeParameters<Transaction>();
        if (transaction == null || transaction.From == null || transaction.To == null)
            return BuildResponse(rpcRequest, null,
                new JsonRpcError("INVALID_TRANSACTION", "Unable to parse transaction " + rpcRequest.Parameters, null));
        transaction = transaction with
        {
            Hash = transaction.HashObject()
        };
        _blockchain.AddPendingTransaction(transaction);
        await _appSender.GossipTransaction(transaction);
        return BuildResponse(rpcRequest, transaction, null);
    }
```

```csharp
            await _grpcClient.SendAppGossipAsync(new SendAppGossipMsg
            {
                Msg = transaction.SerializeJsonByteString()
            });
```

```csharp
    internal void AddPendingTransaction(Transaction transaction)
    {
        TransactionPool.TryAdd(transaction.Hash, transaction);
    }
```

When the `AppSender.SendAppGossip` method is called on one node, AvalancheGo
will gossip the message to all the other nodes. On these nodes, AvalancheGo will
call the
[VM.AppGossip](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.VM.AppGossip)
method that we need to add to our VM implementation.

```csharp
    public override Task<Empty> AppGossip(AppGossipMsg request, ServerCallContext context)
    {
        var transaction = request.Msg.DeserializeJsonByteString<Transaction>();
        if (transaction != null) _blockchain.AddPendingTransaction(transaction);
        return Task.FromResult(new Empty());
    }
```

### Blockchain Initialization

To get started, we need a genesis block that will be used during the
VM initialization part. When the `genesis` argument is passed to the program, we
will generate the `genesis.json` file using dummy data (Alice and Bob's
balances). 

```csharp
if (args.Length == 1 && args[0] == "genesis")
{
    Genesis.Create();
    return;
}
```

```csharp
public static class Genesis
{
    internal static void Create()
    {
        var genesisBlock = new Block(
            new Dictionary<string, ulong> { { "Alice", 1000 }, { "Bob", 1000 } },
            new Transaction[] { },
            0,
            DateTimeOffset.Now.ToUnixTimeMilliseconds(),
            Id.Default.ToString(),
            Id.Default.ToString());
        var hash = genesisBlock.HashObject();
        genesisBlock = genesisBlock with
        {
            Hash = hash
        };
        File.WriteAllText("genesis.json", genesisBlock.SerializeJson());
    }
}
```

Our VM implementation is empty for now (returning dummy data). We need to
implement the different method to parse and manage blocks.

Let's review some of these changes in detail. 

`Initialize` now parses the genesis block, adds it to our blockchain as a final
block, and the data returned comes from the parsed block. 

```csharp
    public override Task<InitializeResponse> Initialize(InitializeRequest request, ServerCallContext context)
    {
        var genesisBlock = request.GenesisBytes.DeserializeJsonByteString<Block>();
        if (genesisBlock == null) return Task.FromResult(new InitializeResponse());
        if (request.ServerAddr != _globalSettings.AvalancheRpcUrl) _globalSettings.AvalancheRpcUrl = request.ServerAddr;
        _blockchain.AddFinalBlock(genesisBlock);
        return Task.FromResult(new InitializeResponse
        {
            Bytes = request.GenesisBytes,
            Height = genesisBlock.Height,
            LastAcceptedId = genesisBlock.Hash.HexStringToByteString(),
            LastAcceptedParentId = genesisBlock.ParentHash.HexStringToByteString(),
            Timestamp = genesisBlock.Timestamp.LongToTimestamp()
        });
    }
```

`SetState` must return the latest final block.

```csharp
    public override Task<SetStateResponse> SetState(SetStateRequest request, ServerCallContext context)
    {
        _blockchain.State = request.State;
        var lastBlock = _blockchain.LatestBlock;
        return Task.FromResult(new SetStateResponse
        {
            Bytes = lastBlock.SerializeJsonByteString(),
            Height = lastBlock.Height,
            LastAcceptedId = lastBlock.Hash.HexStringToByteString(),
            LastAcceptedParentId = lastBlock.ParentHash.HexStringToByteString(),
            Timestamp = lastBlock.Timestamp.LongToTimestamp()
        });
    }
```

`ParseBlock` parses the block and adds it to our blockchain as a pending
block. The data returned comes from the parsed block.

```csharp
    public override Task<ParseBlockResponse> ParseBlock(ParseBlockRequest request, ServerCallContext context)
    {
        _logger.LogInformation("Parse block {body}", request.Bytes.ToStringUtf8());
        var block = request.Bytes.DeserializeJsonByteString<Block>();
        if (block == null) return Task.FromResult(new ParseBlockResponse());
        _blockchain.AddPendingBlock(block);
        return Task.FromResult(new ParseBlockResponse
        {
            Height = block.Height,
            Id = block.Hash.HexStringToByteString(),
            ParentId = block.ParentHash.HexStringToByteString(),
            Status = Status.Processing,
            VerifyWithContext = false,
            Timestamp = block.Timestamp.LongToTimestamp()
        });
    }
```

At this point, we can start our VM using `dotnet avalanche run`, and we will
have a valid blockchain with a basic JSON-RPC endpoint. 

You can import this [Postman
collection](https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet.postman_collection.json)
to send a transaction and check the blockchain state. When we send a
transaction and check the blockchain state, we see the transaction in the
transaction pool, but no blocks are built because the block building mechanism
is not yet implemented.

### Block Building

The `BackgroundWorker` class must be registered as a hosted service.

```csharp
builder.Services.AddHostedService<BackgroundWorkerService>();
```

When it is started, it checks every second if a new block can be built, and if
it can, it calls the `Messenger.NotifyBuildBlock` method. 

```csharp
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var seconds = 1;
        _logger.LogInformation("Background worker started with {seconds}s interval", seconds);
        using var timer = new PeriodicTimer(TimeSpan.FromSeconds(seconds));
        while (
            !stoppingToken.IsCancellationRequested &&
            await timer.WaitForNextTickAsync(stoppingToken))
            await Tick();
        _logger.LogInformation("Background worker stopped");
    }

    private Task Tick()
    {
        if (_blockchain.ShouldBuildBlock())
            return _serviceProvider.GetRequiredService<MessengerClient>().NotifyBuildBlock();
        return Task.CompletedTask;
    }
```

```csharp
    internal bool ShouldBuildBlock()
    {
        if (State != State.NormalOp) return false;
        CleanPendingBlocks();
        return PendingBlocks.IsEmpty && !TransactionPool.IsEmpty;
    }
```

```csharp
            await _grpcClient.NotifyAsync(new NotifyRequest
            {
                Message = Message.BuildBlock
            });
```

Supposing we have a 3 nodes network with _nodeX_, _nodeY_, _nodeZ_.
Our VM on _NodeX_ has decided that it's ready to issue a new block.

_on nodeX_

Our VM calls the `Messenger.Notify` method to notify AvalancheGo that a new
block can be built. When AvalancheGo is notified, it calls the `VM.BuildBlock`
method. 

```csharp
    public override Task<BuildBlockResponse> BuildBlock(BuildBlockRequest request, ServerCallContext context)
    {
        var block = _blockchain.BuildBlock(_blockchain.TransactionPool.Values);
        _logger.LogInformation("Built block {block}", block);
        return Task.FromResult(new BuildBlockResponse
        {
            Bytes = block.SerializeJsonByteString(),
            Height = block.Height,
            Id = block.Hash.HexStringToByteString(),
            ParentId = block.ParentHash.HexStringToByteString(),
            Timestamp = block.Timestamp.LongToTimestamp(),
            VerifyWithContext = false
        });
    }
```

Our blockchain's block building mechanism is very simple. It takes all the
transactions in the transaction pool and adds them to the block. If the
transaction is valid, it as marked as accepted and the block's balances are
updated accordingly. Else, it is marked as rejected and balances are not
updated. 

```csharp
    internal Block BuildBlock(IEnumerable<Transaction> pendingTransactions)
    {
        if (PreferredBlock != null) return PreferredBlock;
        var lastBlock = FinalBlocks[LatestBlockHash];
        var balances = lastBlock.Balances.ToDictionary(k => k.Key, v => v.Value);
        var transactions = new List<Transaction>();
        foreach (var tx in pendingTransactions)
            if (balances.ContainsKey(tx.From) && balances[tx.From] > tx.Amount)
            {
                balances[tx.From] -= tx.Amount;
                if (!balances.ContainsKey(tx.To)) balances.Add(tx.To, 0);
                balances[tx.To] += tx.Amount;
                transactions.Add(tx with { Status = TransactionStatus.Accepted });
            }
            else
            {
                transactions.Add(tx with { Status = TransactionStatus.Rejected });
            }

        var block = Block.Create(
            balances,
            transactions.ToArray(),
            lastBlock.Height + 1,
            lastBlock.Hash);
        PendingBlocks.TryAdd(block.Hash, block);
        return block;
    }
```

When a new block is built, AvalancheGo will perform the following calls to the
VM before broadcasting it to the other nodes:

`VM.BlockVerify` must check that the block is valid. If it is, we return the
block's timestamp property.

```csharp
    public override Task<BlockVerifyResponse> BlockVerify(BlockVerifyRequest request, ServerCallContext context)
    {
        var block = request.Bytes.DeserializeJsonByteString<Block>();
        if (_blockchain.Verify(block))
            return Task.FromResult(new BlockVerifyResponse
            {
                Timestamp = block.Timestamp.LongToTimestamp()
            });
        return Task.FromResult(new BlockVerifyResponse());
    }
```

To verify the block's validity, we simply try to build a new one using the
block's transaction and timestamp. If the hashes are equal, then the block is
valid.

```csharp
    internal bool Verify([NotNullWhen(true)] Block? block)
    {
        if (block != null)
        {
            var expectedHash = block.HashBlock();
            if (expectedHash == block.Hash
                && RebuildBlockHash(block) == block.Hash)
                return true;
            _logger.LogInformation(
                "Block verify failed. Actual : {block}, expectedHash : {expectedHash}, rebuiltBlock : {rebuiltBlock}",
                block, expectedHash, BuildBlock(block.Transactions));
        }

        return false;
    }

    private string RebuildBlockHash(Block block)
    {
        block = BuildBlock(block.Transactions) with
        {
            Timestamp = block.Timestamp
        };
        return block.HashBlock();
    }
```

`VM.SetPreference` marks this block as the next preferred block for the current
node.

```csharp
    public override Task<Empty> SetPreference(SetPreferenceRequest request, ServerCallContext context)
    {
        _blockchain.SetPreference((Id)request.Id);
        return Task.FromResult(new Empty());
    }
```

Now AvalancheGo will broadcast our block to the other nodes.

_on nodeY and nodeZ_

AvalancheGo will perform the following calls to the VM : 

`VM.ParseBlock` must parse the block, and add it to our `PendingBlocks` store,
just like we have done during the blockchain
[initialization](#blockchain-initialization) with the genesis block.

It will then call `VM.BlockVerify` and `VM.SetPreference`, just like on _nodeX_.

_on all nodes_

`VM.BlockAccept` must mark the block as final. 

```csharp
    public override Task<Empty> BlockAccept(BlockAcceptRequest request, ServerCallContext context)
    {
        _blockchain.Accept((Id)request.Id);
        return Task.FromResult(new Empty());
    }
```

When the block is finalized, we must simply add it to our `FinalBlocks` store,
and clear any data related to any pending blocks since they are linked to the
previous block. 

```csharp
    internal void Accept(Id id)
    {
        var hash = id.ToString();
        _logger.LogInformation("Blockchain.Accept - {hash}", hash);
        if (PendingBlocks.TryGetValue(hash, out var block))
            AddFinalBlock(block);
        else
            _logger.LogError("Blockchain.Accept error block not found - {hash} ", hash);
        PendingBlocks.Clear();
        PreferredBlock = null;
    }
```

We also remove mark our newly accepted block as the `LatestBlock`. All its
transactions are also removed from the transaction pool.

```csharp
    internal void AddFinalBlock(Block block)
    {
        FinalBlocks.TryAdd(block.Hash, block);
        LatestBlockHash = block.Hash;
        foreach (var tx in block.Transactions) TransactionPool.TryRemove(tx.Hash, out var _);
    }
```

### Managing Conflicts

Conflicts happen when two or more nodes propose the next block at the same time.
AvalancheGo takes care of this and decides which block should be considered
final, and which blocks should be rejected using Snowman consensus.
On the VM side, all there is to do is implement the `VM.BlockAccept` and
`VM.BlockReject` methods.

_nodeX proposes block `0x123...`, nodeY proposes block `0x321...` and nodeZ
proposes block `0x456`_

There are three conflicting blocks and AvalancheGo decides which block must
be accepted. Supposing it accepts block `0x123...`. The following RPC methods
are called on all nodes :

`VM.BlockAccept` with `0x123...` as the `Id` parameter.

`VM.BlockReject` with `0x321...` as the `Id` parameter.
`VM.BlockReject` with `0x456...` as the `Id` parameter.

```csharp
    public override Task<Empty> BlockReject(BlockRejectRequest request, ServerCallContext context)
    {
        _blockchain.Reject((Id)request.Id);
        return Task.FromResult(new Empty());
    }
```

To reject the block, we simply remove it from the `PendingBlocks` store and
clear its `PreferedBlock` status.

```csharp
    internal void Reject(Id id)
    {
        var hash = id.ToString();
        if (PreferredBlock?.Hash == hash) PreferredBlock = null;
        PendingBlocks.TryRemove(hash, out var _);
    }
```

## Trying Out

Let's try out our newly built VM. Run `dotnet avalanche run` to start our local
network. We will now execute some `curl` commands to interact with the JSON-RPC
endpoint. Our 5 nodes listen on ports `9650`, `9652`, `9654`, `9656`, and
`9658`. In our examples, we will use various ports randomly to see that the
nodes are well synchronized.

These commands are included in this [Postman
collection](https://github.com/boulix3/subnet-from-scratch-csharp/blob/main/src/MySubnet.postman_collection.json)

When the nodes are fully ready, we can start by getting the latest block from
our Subnet VM by executing the `LatestBlock` endpoint: 

```shell
curl --location 'http://127.0.0.1:9652/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :1,
    "method" :"LatestBlock"    
}'
```

If the result is a 404, simply wait a little for the local network to finish
its startup.

The expected result is the genesis block : 

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": null,
  "result": {
    "balances": {
      "Alice": 1000,
      "Bob": 1000
    },
    "transactions": [],
    "height": 0,
    "timestamp": 1680605006469,
    "hash": "0xbc082052bf3c7ace9800d61a88be630a2527bd41baa116153d50a5ad75261324",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
  }
}
```

Now, let's send some coins from Alice to Bob by executing the `Transfer`
endpoint : 

```shell
curl --location 'http://127.0.0.1:9650/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :3,
    "method" :"Transfer",
    "params":{
        "from":"Bob",
        "to":"Alice",
        "amount":100
    }
}'
```

The VM should register the transaction and the expected output should be : 

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": null,
  "result": {
    "from": "Bob",
    "to": "Alice",
    "amount": 100,
    "status": "Pending",
    "hash": "0xd1fff89a3d78ccc64541f110f466eef7efa3377bc3cbbd1cae759d55cc3710f1"
  }
}
```

Let's get the latest block again : 

```shell
curl --location 'http://127.0.0.1:9654/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :1,
    "method" :"LatestBlock"    
}'
```

We can see the new block containing the previous transaction : 

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": null,
  "result": {
    "balances": {
      "Alice": 1100,
      "Bob": 900
    },
    "transactions": [
      {
        "from": "Bob",
        "to": "Alice",
        "amount": 100,
        "status": "Accepted",
        "hash": "0xd1fff89a3d78ccc64541f110f466eef7efa3377bc3cbbd1cae759d55cc3710f1"
      }
    ],
    "height": 1,
    "timestamp": 1680775417773,
    "hash": "0xcdc21e198df364971fea285dc4690f248fa97c46a83feb11e74702985f30e5d9",
    "parentHash": "0xbc082052bf3c7ace9800d61a88be630a2527bd41baa116153d50a5ad75261324"
  }
}
```
