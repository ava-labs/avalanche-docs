```javascript
const { ethers } = require("ethers");
const dotenv = require("dotenv");

const chains = require("../constants/chains");
/* Get contract addresses from the file we generated by running the deploy script */
const {
	AVAX_BRIDGE_ADDRESS,
	AVAX_TOKEN_ADDRESS,
	SUBNET_BRIDGE_ADDRESS,
} = require("../variables/contractAddresses");
/* Get ABIs of the contracts directly from the artifact folder created by hardhat after each compilation */
const SUBNET_BRIDGE_ABI =
	require("../artifacts/contracts/Bridge/SubnetBridge.sol/SubnetBridge").abi;
const AVAX_BRIDGE_ABI =
	require("../artifacts/contracts/Bridge/AvaxBridge.sol/AvaxBridge").abi;
const AVAX_TOKEN_ABI =
	require("../artifacts/contracts/Token/AvaxToken.sol/AvaxToken").abi;
dotenv.config();

/* 
  BurnOrLock script that allows us to both burn and lock tokens
  On Avax it allows us to lock ERC20 tokens
  On Subnet it allows us to burn native tokens
*/
module.exports = burnOrLock = async (from, amount) => {
	let provider;
	let signer;
	let bridgeContract;
	/* This script takes command line argument to indicate which chain we are using */
	if (from === "avax") {
		/* Initialize; provider, signer and tokenContract */
		provider = new ethers.providers.JsonRpcProvider(chains.avax.rpcUrl);
		signer = new ethers.Wallet(process.env.BRIDGE_USER_PRIVATE_KEY, provider);
		const tokenContract = new ethers.Contract(
			AVAX_TOKEN_ADDRESS,
			AVAX_TOKEN_ABI,
			signer
		);

		/* Approve bridge to use the token of the sender before trying to lock tokens */
		const approveTx = await tokenContract.approve(
			AVAX_BRIDGE_ADDRESS,
			ethers.utils.parseEther(amount)
		);
		await approveTx.wait();

		/* Initialize bridgeContract  */
		bridgeContract = new ethers.Contract(
			AVAX_BRIDGE_ADDRESS,
			AVAX_BRIDGE_ABI,
			signer
		);

		/* User locks ERC20 tokens to the bridge */
		const lockTx = await bridgeContract.lock(
			signer.address,
			ethers.utils.parseEther(amount)
		);
		const minedTx = await lockTx.wait();

		console.log("Successfully locked amount on avax: ", amount);
		console.log("At block: ", minedTx.blockNumber);
		/* Get user's ERC20 balance after lock */
		const newUserBalance = await tokenContract.balanceOf(signer.address);
		/* Get bridge's ERC20 balance after lock */
		const newBridgeBalance = await tokenContract.balanceOf(AVAX_BRIDGE_ADDRESS);
		console.log(
			"Updated balance of user after burn: ",
			ethers.utils.formatEther(newUserBalance)
		);
		console.log(
			"Updated balance of bridge after burn: ",
			ethers.utils.formatEther(newBridgeBalance)
		);
	} else if (from === "subnet") {
		/* Initialize; provider, signer and tokenContract */
		provider = new ethers.providers.JsonRpcProvider(chains.subnet.rpcUrl);
		signer = new ethers.Wallet(process.env.BRIDGE_USER_PRIVATE_KEY, provider);
		bridgeContract = new ethers.Contract(
			SUBNET_BRIDGE_ADDRESS,
			SUBNET_BRIDGE_ABI,
			signer
		);
		/* User burns native tokens */
		const burnTx = await bridgeContract.burn(signer.address, {
			value: ethers.utils.parseEther(amount),
		});
		await burnTx.wait();
		console.log("Successfully burned amount on subnet: ", amount);

		/* Get user's native token balance after burn */
		const newUserBalance = await signer.getBalance();
		console.log(
			"Updated balance of user after burn: ",
			ethers.utils.formatEther(newUserBalance)
		);
	} else {
		return;
	}
};
```
