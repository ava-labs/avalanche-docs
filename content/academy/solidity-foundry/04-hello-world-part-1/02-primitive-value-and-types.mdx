---
title: Primitive Values and Types
description: Learn about Solidity
updated: 2024-06-28
authors: [Andrea Vargas, Ash, martineckardt]
icon: Book
---

All code, regardless of the language it is written in, can be described (in very very simple terms) as the manipulation of values. Therefore, if we want to learn a new language, we should start at the type of values we will be manipulating; this is where we will start our Solidity journey.

## Declaring Variable

We first note that Solidity is a statically-typed language; this means that for any variable that we declare, we must declare its type at the time of initialization. Therefore, the general syntax for declaring a variable is as follows:

```solidity
<type> <name>;
```

The following are examples of us declaring variables in Solidity:

```solidity
address addr;
uint256 num;
bool b;
```

For right now, we won't focus on what the types mentioned above actually mean. However, the biggest takeaway is that for any variable that we initialize, we must declare its type.

## Defining Variables

Now that we know how to declare a variable in Solidity, the other half of the puzzle that we want to solve for is actually assigning a value to these variables. The following code snippet is an example of how we would assign values to variables:

```solidity
addr = 0x7f610402ccc4CC1BEbcE9699819200f5f28ED6e3;
num = 0;
b = false;
```

Rather than having to take the two separate steps of declaring a variable and then defining said variable, we can do these two steps in just line; the following code shows how we would do this:

```solidity
address addr = 0x7f610402ccc4CC1BEbcE9699819200f5f28ED6e3;
uint256 num = 0;
bool b = false;
```

## Types

Now that we've discussed the process of both declaring and defining a variable, let's return to the topic of types. In Solidity, the following is a (non-exhaustive) list of elementary types that are available:

- Unsigned Integers: any value which is an unsigned integer is a nonnegative integer. Furthermore, the unsigned integer type is not a singular type, but rather a group of unsigned integers types differentiated by their bit size. Any unsigned integer type has a bit size that is a multiple of 8. So the following types are valid unsigned integer types: uint8, uint16, uint24, uint32, ..., uint256 (uint256 is the maximum unsigned integer bit size). Furthermore, for any unsigned integer uintx (where x is a multiple of 8 and between 0 and 256), we have that the range of uintx is from 0 up to (but not including) 2^(x).
- Signed Integers: any value which is a signed integer is a integer that can be either negative or positive. Like the unsigned integer type, the signed integer type is a group of signed integer types differentiated by their bit size. Any signed integer type has a bit size that is a multipe of 8. Examples of signed integer types are the following: int8, int16, int24, ..., int256 (int256 is the maximum signed integer size). Furthermore, for any signed integer intx (where x is a multiple of 8 and between 0 and 256), we have that the range of intx is from -2^(x - 1) up to (but not including) 2^(x - 1)
- Addresses: the address type consists of a 20-byte value. This type, as its name might suggest, represents the address of an EVM account.
- Booleans: can be either true or false. Treating booleans as integers, a true value is equal to 1 while a false value is equal to 0.
