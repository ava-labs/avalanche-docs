# BurnOrLock.js

```javascript
const { ethers } = require("ethers");
const dotenv = require("dotenv");

const chains = require("../constants/chains");
/* Get contract addresses from the file we generated by running the deploy script */
const {
    AVAX_BRIDGE_ADDRESS,
    AVAX_TOKEN_ADDRESS,
    SUBNET_BRIDGE_ADDRESS,
} = require("../variables/contractAddresses");
/* Get ABIs of the contracts directly from the artifact folder created by hardhat after each compilation */
const SUBNET_BRIDGE_ABI =
    require("../artifacts/contracts/Bridge/SubnetBridge.sol/SubnetBridge").abi;
const AVAX_BRIDGE_ABI =
    require("../artifacts/contracts/Bridge/AvaxBridge.sol/AvaxBridge").abi;
const AVAX_TOKEN_ABI =
    require("../artifacts/contracts/Token/AvaxToken.sol/AvaxToken").abi;
dotenv.config();

/* 
  BurnOrLock script that allows us to both burn and lock tokens
  On Avax it allows us to lock ERC20 tokens
  On Subnet it allows us to burn native tokens
*/
module.exports = burnOrLock = async (from, amount) => {
    let provider;
    let signer;
    let bridgeContract;
    /* This script takes command line argument to indicate which chain we are using */
    if (from === "avax") {
        /* Initialize; provider, signer and tokenContract */
        provider = new ethers.providers.JsonRpcProvider(chains.avax.rpcUrl);
        signer = new ethers.Wallet(process.env.BRIDGE_USER_PRIVATE_KEY, provider);
        const tokenContract = new ethers.Contract(
            AVAX_TOKEN_ADDRESS,
            AVAX_TOKEN_ABI,
            signer
        );

        /* Approve bridge to use the token of the sender before trying to lock tokens */
        const approveTx = await tokenContract.approve(
            AVAX_BRIDGE_ADDRESS,
            ethers.utils.parseEther(amount)
        );
        await approveTx.wait();

        /* Initialize bridgeContract  */
        bridgeContract = new ethers.Contract(
            AVAX_BRIDGE_ADDRESS,
            AVAX_BRIDGE_ABI,
            signer
        );

        /* User locks ERC20 tokens to the bridge */
        const lockTx = await bridgeContract.lock(
            signer.address,
            ethers.utils.parseEther(amount)
        );
        const minedTx = await lockTx.wait();

        console.log("Successfully locked amount on avax: ", amount);
        console.log("At block: ", minedTx.blockNumber);
        /* Get user's ERC20 balance after lock */
        const newUserBalance = await tokenContract.balanceOf(signer.address);
        /* Get bridge's ERC20 balance after lock */
        const newBridgeBalance = await tokenContract.balanceOf(AVAX_BRIDGE_ADDRESS);
        console.log(
            "Updated balance of user after lock: ",
            ethers.utils.formatEther(newUserBalance)
        );
        console.log(
            "Updated balance of bridge after lock: ",
            ethers.utils.formatEther(newBridgeBalance)
        );
    } else if (from === "subnet") {
        /* Initialize; provider, signer and tokenContract */
        provider = new ethers.providers.JsonRpcProvider(chains.subnet.rpcUrl);
        signer = new ethers.Wallet(process.env.BRIDGE_USER_PRIVATE_KEY, provider);
        bridgeContract = new ethers.Contract(
            SUBNET_BRIDGE_ADDRESS,
            SUBNET_BRIDGE_ABI,
            signer
        );
        /* User burns native tokens */
        const burnTx = await bridgeContract.burn(signer.address, {
            value: ethers.utils.parseEther(amount),
        });
        const minedTx = await burnTx.wait();
        console.log("Successfully burned amount on subnet: ", amount);
        console.log("At block: ", minedTx.blockNumber);

        /* Get user's native token balance after burn */
        const newUserBalance = await signer.getBalance();
        console.log(
            "Updated balance of user after burn: ",
            ethers.utils.formatEther(newUserBalance)
        );
    } else {
        return;
    }
};
```
