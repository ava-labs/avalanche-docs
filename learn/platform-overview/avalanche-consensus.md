---
description: Avalancheコンセンサスプロトコルについて深く詳しく説明します
---

# Avalancheコンセンサス

コンセンサスは、決断に合意をするようになるというタスクです。コンピュータは、コンセンサスプロトコルと呼ばれる一連のステップに従うことにより、コンセンサスに到達することができます。Avalancheは、スケーラブルで堅牢かつ分散化可能な新しいコンセンサスプロトコルです。低レイテンシーと高いスループットを備えています。エネルギー効率で、特別なコンピュータハードウェアは必要ありません。逆境の状況でうまく機能し、「51%の攻撃」に耐えられます。このドキュメントでは、Avalancheコンセンサスプロトコルについて説明します。[ホワイトペーパー](https://www.avalabs.org/whitepapers)

## ビデオ

{% embed url="https://www.youtube.com/watch?v=ZUF9sIu-D_k" caption="" %}

## 直感

まず、プロトコルについての直感を開発しましょう。昼食に何を入手するかに合意しようとする人々でいっぱいお部屋を想像してみましょう。ピザとバーベキューの間のバイナリ選択であるとしましょう。最初はピザを好む人もいるかもしれませんが、他の人は最初はバーベキューを好む人もいます。最終的に、みんなの目標は、コンセンサスを達成することです****。

誰もが、自分の昼食が何かということを、部屋にいる人々のランダムなサブセットに尋ねます。半数以上を超えるピザと言えば、「オック、ピザに向かって変化がみられるように思えます。今はピザが好みます。」つまり、多数派_の_好みを採用しています。同様に、多数がバーベキューと言う場合、バーベキューを好みに採用します。

誰もがこのプロセスを繰り返します。各ラウンドで、より多くの人が同じ好みを持っています。オプションを好む人数が多すぎると、多数回答を受信し、そのオプションを自分の好みにしたものとします。十分なラウンドを経て、コンセンサスに到達し、1つのオプションを決定します。

## Snowball

上の直感により、AvalancheコンセンサスのビルドブロックであるSnowball Algorithmを概説します。Snowballアルゴリズムを見直しましょう。

### パラメータ

* _n_：参加者数
* _k（_サンプルサイズ）： 1から_n間で_
* α（クオーラムサイズ）：1から_k間で_
* β: >= 1

### アルゴリズム

```text
preference := pizza
consecutiveSuccesses := 0
while not decided:
  ask k random people their preference
  if >= α give the same response:
    preference := response with >= α
    if preference == old preference:
      consecutiveSuccesses++
    else:
      consecutiveSuccesses = 1
  else:
    consecutiveSuccesses = 0
  if consecutiveSuccesses > β:
    decide(preference)
```

### アルゴリズム

ピザやバーベキューを好む人はみんながいます。誰かが決定するまでは、__k人の問い合わせ（サンプルサイズ）し__、自分の好きなものを尋ねます。α以上で同じレスポンスを与える場合、新しい優先としてαは採用されます。αは、__クオラムサイズと呼ばれるものです。新しい設定が古い好みと同じ場合、`consecutiveSuccesses`カウンターは増加されます。新しい好みが異なる場合、以前の好みは`consecutiveSucccesses`カウンターを。`1`レスポンスがクオーラム（同じレスポンスのαの過半数）を受け取らない場合、`consecutiveSuccesses`カウンターは設定されます。`0`

同じレスポンスβ回数について、みんなでクオラムが発生するまで、これを繰り返します。ある人がピザを決定した場合、プロトコルに従う他の人物は最終的にピザを決定します。

ランダムサンプリングによって引き起こされる好みのランダム変化により、1つの選択のためのネットワーク優先が発生します。これにより、それが不可逆化が起き、その後、ノードが決定できるまで、より多くのネットワーク優先が発生します。

{% hint style="info" %}素晴らしいビジュアリゼーションを[ご](https://tedyin.com/archive/snow-bft-demo/#/snow)覧ください。{% endhint %}

ここでは、ピザやバーベキュー間でバイナリ選択がありますが、Snowballを適応して、多くの選択肢で決定に関するコンセンサスを達成することができます。

ライブ性と安全閾値は、パラメータ化可能になります。クオーラムサイズがαが増加し、安全閾値が増加し、ライブネス閾値が低下します。つまり、ネットワークはより多くのビザンティン（故意に誤りがあり、悪意のある）ノードに耐え、安全性の高いものを維持し、最終的にすべてのノードが合意するようになります。ライブネス閾値は、プロトコルが進化できない前に許容できる悪意のある参加者の数です。

定数であるこれらの値は、Avalancheネットワーク上に存在するものではありません。__サンプルサイズkです`20`。したがって、ノードがノードグループに自分の意見を尋ねたとき、ネットワーク全体から`20`ノードにのみ問い合わせる場合があります。クオーラムサイズ、αは以下のとおりです`14`。`14`したがって、より多数のノードが同じレスポンスを与える場合、そのレスポンスはクエリーノードが好みに適用されます。決定閾値は、βです`20`。ノードは、`20`連続したクオラム（αメジャリティ）レスポンスを受け取った後、選択を選択します。

ネットワーク上のノード数、n__が増大するにつれて、Snowballは非常にスケーラブルです。`20`ネットワーク内の参加者数にかかわらず、与えられたクエリーでノードだけがクエリされるため、一切の合意メッセージの数は変わります。なぜなら、ネットワークに何千ものノードが存在する場合も、ノードにクエリだけがクエリされるため、ネットワーク上の参加者数は変わります。

## DAGs（指向****された****アサイクリックグラフ****）

次に、DAGあるいは指示されたアサイクリックグラフと呼ばれるデータ構造を紹介しましょう。DAGにより、決定の**一部**順序が提供されます。たとえば、この図でDAGをチェックする：

![基本 DAG](../../.gitbook/assets/cons-01-Frame16.png)

**********a**は****bは****d以前で、**cは以前のもの****です。 過渡的に、eは前で**起こるものと言えるでしょう。 しかし、部分的な命令であるため、一部の要素については順序が定義されていないことになります****。******たとえば、**b**とc両方がa後に**出たもの**の、bがc前後あるいはc後後に**出たかどうかという概念は存在しない****。

追加のDAG関連の2つのコンセプトは、**祖先**と子孫です****。アンセスタは、DAG内の任意のノードで、あなたがまでのラインナップを描くことができます。******例えば、**dの祖先はa、****b、cです****。 **eの祖先は****a、cであり、c**です****。******aの子孫は、b****,c,d****, ****e.**bの子孫はd****です****。

たとえば、ビットコインとイーサリアムの両方とも、すべてのブロックに1人の親と1人の子供を持つリニアチェーンを持ちます。Avalancheは、DAGを使用して、線形チェーンではなくデータを保存します。DAGの各要素には、複数の親がいる場合があります。DAG内の親子関係により、アプリケーションレベルの依存性を意味するものではありません。

コンセンサスプロトコルでは、ゲームの名前は、DAG**に競合**する取引を取り込むことを防ぐことです。コンフリクトは、アプリケーション定義です。異なるアプリケーションは、2つのトランザクションが競合する場合に何を意味するという概念を持ちます。たとえば、P2P支払システムでは、同じUTXO[（未使用トランザクションアウトプット）](https://en.wikipedia.org/wiki/Unspent_transaction_output)を消費するトランザクションが競合する場合があります。Avalancheでは、すべての取引は、競合するトランザクションで構成される**コフリセットに**属します。DAGにコントリビュートセットで1つのトランザクションのみが含まれます。各ノードは、コフリクションセットで1**つのトランザクションを**好みます。

## 作業例

以下のパラメータでAvalancheネットワークが稼働するとします。__サンプルサイズkです`4`。クオーラムサイズ、αは以下のとおりです`3`。連続した成功数、βは以下のとおりです`4`。

![作業例 1](../../.gitbook/assets/cons-02-Consensus_Doc_txY.png)

ノードは、新しいトランザクションYについて知ります。これは、上記のパラメーターに基づきネットワークに問い合わせられます****。_k（_`4`）バリデータに問い合わせ、「この取引を好むか？」と尋ねます。`3`回答が戻りました。そのうち3人は**イエスと言われ、そのうち1人はノーと言います。 quorumサイズであるαは、イエスレスポンスのαの過半数（quorum）が存在**します****。これで、ノードはDAGを更新します。

![作業例](../../.gitbook/assets/cons-03-Consensus_Doc_txY-6.png)

トランザクションにαの過半数が返す場合、そのトランザクションに秘密を置くことになります。「このトランザクションについてのネットワークを問い合わせたとき****、αの過半数が好みと言った」というブール値であることを返します。例では、トランザクションYは、キットが発生します。

また、頂点のキットの合計で、子孫のヒットの合計で****信頼の概念があります。たとえば、**トランザクションVは、キットを**持っています。`3`また、3人の子孫を持ち、チャットを持ち、その信頼がより高まるようにしています。`4`同様に、**W**と**Xのトランザクションは**両方ともチャットを持ち、両方ともチャットで子孫を持ち、その両方ともチャットを持ちますので、それぞれ信頼性があります`2`。トランザクションYは、自信を持っています`1`。

****連続で成功したことは、Snowballと同じです。トランザクション、あるいはトランザクションの末裔であるトランザクションが、成功したαマリアリティクエリレスポンスを受け取った回数です。以前は、トランザクションVは、そのものとその2つの子で`3`連続した成功があり、現在では、トランザクションYで連続`4`した成功があります。 トランザクションWとXで同様に成功しました。

![作業例](../../.gitbook/assets/cons-04-Consensus_Doc_txY-2.png)

この例では、受諾閾値であるβが以下のようになります`4`。トランザクションVは、連続`4`で成功したので、受け入れられます**。**このノードは、他のすべての正しいノードが最終的にこのトランザクションを受け付けることを確実にしています。

![作業例](../../.gitbook/assets/cons-05-Consensus_Doc_txY-3.png)

ここで、トランザクションYと競合**する**トランザクションYについてノードが覚えているとします。これは、前と同じステップに従い、_k（_`4`）バリデータをサブサンプルして、トランザクションYを好むかどうか尋ねることです。この場合、Y'を好まないと2つが言います。今回はαの過半数レスポンスがなく、DAGはそれに合わせて更新されます。

![作業例](../../.gitbook/assets/cons-06-Consensus_Doc_txY-4.png)

トランザクションYとY'は、コントラクトセットであります。トランザクションYは、αマラティックレスポンスが得られないため、チャットは発生しません。キットを持たず、キットで子孫がいかなるものもいないから`0`安心しています。以前のクエリではαの過半数レスポンスが得られないため、連続`0`した成功を収めています。我々の連続した成功カウンターは、からに移動`2`します。`0`その信頼はまだです`2`。

`0`指定されたトランザクションを好むかどうかというノードが尋ねられた場合、そのトランザクションがトランザクションのコントリビュートにあたって、そのトランザクションが最高の信頼度を持つ場合、イエスに返答されます。 この例では、トランザクションYは信頼性`1`を持ち、トランザクションYは信頼を持ち、トランザクションYは信頼を持ち、トランザクションYは信頼を持ちますので、ノードはトランザクションYより好みます。

![作業例](../../.gitbook/assets/cons-07-Consensus_Doc_txY-1.png)

ノードは、新しいトランザクションZについて知識し****、以前と同じことがあります。_kノードに問い合わせ_、αの過半数レスポンスを取り戻し、DAGを更新します。

![作業例](../../.gitbook/assets/cons-08-Consensus_Doc_txY-5.png)

トランザクションZまた`1`、継続`1`的な成功への信頼を持ち得ています。処理の祖先も更新されます。トランザクションが連続`4`した成功は存在しません。

## バーティス

この点で説明したすべてが、[AvalancheがAvalancheホワイトペーパー](https://assets-global.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf)でどのように説明されるかです。Ava LabsによるAvalancheコンセンサスプロトコルの実装により、AvalancheGoで実装されることにより、レーテンシーとスループットに最適化が可能になります。最も重要な最適化は、バーティスの使用です****。頂点は、線形ブロックチェーン上のブロックチェーンのブロックのようです。その親のハッシュが含まれており、トランザクションのリストが含まれています。バーティスにより、トランザクションは1つずつではなく、グループで一括して実行できるようになります。DAGは、バーティで構成され、プロトコルは上記の仕方と非常に似ています。

ノードが頂点に投票した場合、頂点内のすべてのトランザクションについて投票としてカウントされ、票は一時的に上方向に適用されます。その中に存在するすべてのトランザクションが承認されたときに、頂点が受け付けられます。頂点に拒否されたトランザクションが含まれている場合、拒否され、その子孫すべてが拒否されます。バーテックスが拒否された場合、有効なトランザクションは新しいバーテックスに再発行されます。新しい頂点が、優先頂点に追加されます。

## ファイナリティ

Avalancheコンセンサスは、安全閾値まで確率的に安全です。つまり、正しいノードが別の正しいノードが拒否したトランザクションを受け付ける確率です。（例えば、ビットコインとイーサリアムで使用されるように）Nakamotoコンセンサスプロトコルでは、ブロックがチェーンに含まれている場合がありますが、その後、削除され、カノニカルチェーンに終了しないようにします。つまり、トランザクション決済を1時間待つことを意味します。Avalancheでは、受諾/拒否は最終的かつ不可逆で数秒で**完了**します。

## 最適化

ノードが、「この頂点を好むか？」と言うだけで効率的ではありません。バリデータを問い合わせるとき。Ava Labsの実装で、クエリ中にノードが尋ねたときに、「この頂点が存在することを考えると、あなたはどちらの頂点が好きですか？」イエス/ノーバイナリに戻る代わりに、ノードは他のノードで好まれた頂点セットを受け取ります。

ノードは、新しいトランザクションを聴く際にのみ問い合わせることはありません。バーチャルな頂点処理が存在しないまで、繰り返しクエリします。バーチャル頂点は、コフリクションがないものです。

世論調査結果を登録する前に、すべての_k_クエリレスポンスが取得するまでノードは待つ必要はありません。トランザクションがαの過半数を得ることができない場合、残りのレスポンスのを待つ必要はありません。

## バリデーター

Avalancheネットワーク上でバリデータになることができれば、悪意のあるアクターが多くのノードが起動できるため、問題に遭遇するでしょう。悪意のあるアクターにより、ノードが大変行動を起こし、安全性やライブネス障害を引き起こす可能性があります。コンセンサスの一部として呼び出されるノードであるバリデータは、ネットワーク上の影響力を持っています。この種の投票スタッピングを防ぐために、現実世界の価値でその影響を支払わなければなりません。実際の価値を使用して、ネットワーク上の影響を購入するというこのアイデアは、プルーフオブステークと呼ばれています。

バリデータになるには、ノードが貴重なもの（AVAX）を**結合（ステーク**）しなければなりません****。AVAXがノードバンドを多すぎるほど、他のノードから問い合わせられる頻度が高い。ノードがネットワークをサンプルする際、一様にランダムではありません。むしろ、ステーク数で重み付けられます。バリデータとして提供されるようになります。

Avalancheは、スラッシュがありません。誤ったレスポンスを与えるや、まったく応答しないなど、バリデーション中にノードがうまく動作しない場合、そのステークは全体的に返却されますが、報酬は存在しません。AVAXの十分な部分が正しいノードで保持される限り、ネットワークは安全であり、バーチャルな取引のために生きています。

## ビッグアイデア

Avalancheで提供される2つの大きなアイデアは、**サブサンプリング**とトランジット**投票です**。サブサンプリングは、ローメッセージオーバーヘッドを持ちます。20件あるバリデータ、2000件のバリデータが存在するかどうかは関係ありません。クエリ中にノードが送信するコンセンサスメッセージ数はまさに一定のままです。

![作業例 8](../../.gitbook/assets/cons-09-Consensus_Doc_txY-7.png)

頂点に投票する場合、先祖である全ての人に投票できる場合、トランザクションスループットをサポートします。それぞれの票は、実際に1回で多くの票です。例えば、上記図で示した場合、ノードが頂点Dに投票した場合、その場合****、すべての祖先に投票することができます。**Dのための投票**は、A****、B****、Cに投票するものでもあります****。

## ルーズエンド

トランザクションは、[AvalancheGo](https://github.com/ava-labs/avalanchego)フルノード上でAPIを呼び出したり、[AvalancheJS](https://github.com/ava-labs/avalanchejs)などのライブラリを使用して作成するユーザーによって作成されます。ノードが着信トランザクションを一緒にバッチする場合、あるいは拒否された頂点からトランザクションを受け付けたトランザクションが再発行され、DAGに追加されたときにバッチする場合、バッチリされます。vertexの親は、DAGの先端にあるノードである、バーテックスの先端の先端から選ばれます。非バーチャル頂点上に構築した場合、ノードが拒否される可能性が高いため、先祖が拒否される可能性が高いため、より高い可能性が高いため、先祖が拒否され、より高い可能性が存在する可能性があまり高くなります。

## その他の観察

紛争取引が生きることは保証されません。トランザクションがライブになりたい場合、競合するトランザクションを発行すべきではありません。

Avalancheは、線形チェーンも機能します。このプロトコルは、主に上記と同じですが、各頂点には1つの親しか持たないものです。これにより、バーティスの合計順序が表示されます。これは、スマートコントラクトなどの別のトランザクションの前にトランザクションが来たかどうか知る必要がある特定のアプリケーションのために便利です。Snowmanは、Ava LabsがリニアチェーンのためのAvalancheコンセンサスプロトコルの実装の名前です。

未定のトランザクションが存在しない場合、Avalancheコンセンサスプロトコルは黙示録です__。つまり、仕事がなくても何もありません。Avalancheは、ノードが常に作業する必要があるProof-ofworkより持続可能性が高い。

Avalancheにはリーダーはいません。あらゆるノードでトランザクションを提案でき、AVAXをステークしたノードがすべてのトランザクションに投票できるようになります。

## なぜ我々が気にするのですか？

Avalancheは、一般的なコンセンサスエンジンです。どんなタイプのアプリケーションが上に置かれることは関係ありません。このプロトコルにより、アプリケーションレイヤーをコンセンサスレイヤーからデカップリングすることができます。Avalanche上でDappを構築する場合、コンフリクトがどのように定義されるか、トランザクションに含まれるものを定義するだけです。ノードが合意に到達するか心配する必要はありません。コンセンサスプロトコルは、何かを入手するブラックボックスであり、受け入れられたか拒否として戻ってきます。

Avalancheは、P2P支払いネットワークだけでなく、あらゆる種類のアプリケーションに使用できます。Avalancheのプライマリネットワークには、既存のイーサリアムDappsと開発ツールと後方互換性があります。イーサリアムのコンセンサスプロトコルは、Avalancheで置き換えられています。

Avalancheは、非常にパフォーマンスです。1秒間に2回の受理遅延で、毎秒数千件の取引を処理できます。

## 概要

Avalancheコンセンサスは、分散システムにおける急激なブレークスルーです。以前に来た古典およびNakamotoのコンセンサスプロトコルとして大きな飛躍を表します。このように、それがどのように機能するかについてよりよく理解ができたようで、Avalanche上でゲーム変更のDappsと金融商品を構築するための他の[ドキュメント](https://docs.avax.network)をチェックしてください。

