---
description: Avalancheコンセンサスプロトコルについて深く掘り下げる

---

# Avalancheコンセンサス

コンセンサスとは、コンピューターのグループに決定に関する合意を取得する作業です。コンピューターはコンセンサスプロトコルと呼ばれる一連のステップに従うことでコンセンサスに達することができます。Avalancheは、拡張性、堅牢性、分散化された新しいコンセンサスプロトコルです。LAN-PARIDE のサポートこれはエネルギー効率が良く、特別なコンピューターハードウェアを必要としません。敵対的な条件で優れたパフォーマンスを発揮し、「51%の攻撃」に強い。この文書ではAvalancheコンセンサスプロトコルについて説明します。ホワイトペーパーは[こちら](https://www.avalabs.org/whitepapers)

## JP-JP-

{% embed url="https://www.youtube.com/watch?v=ZUF9sIu-D\_k" caption="" %}

## JP-JP-

まず、プロトコルについてのいくつかの直感を開発しましょう。昼食に何を求めているかに合意しようとしている人々の満ちた部屋を想像してください。ピザとバーベキューの二進的な選択肢だとします。ピザを好む人もいますが、バーベキューを好む人もいます。しかし、最終的には、みんなの目標は**コンセンサス**を達成することです。

誰もが部屋の人々のランダムなサブセットに彼らの昼食の好みが何であるか尋ねます。「そう、物事がピザに傾いているように見えます。私は今、ピザが好きです」と述べています。つまり、彼らは多数派の_好み_を採用しています。同様に、大多数がバーベキューを言う場合、人はバーベキューを好みに採用しています。

誰もがこのプロセスを繰り返します。各ラウンド、ますます多くの人々が同じ好みを持っています。これは、選択肢を好む人ほど、誰かが多数返信を受け、そのオプションを好みに採用する可能性が高いからです。十分なラウンドの後、彼らはコンセンサスに達し、1つのオプションを決定します。

## スノーボール

上記の直感は、雪玉アルゴリズム(Avalanche Consensus)の構築ブロックである、雪玉アルゴリズム(Snowball Algorithm)を概説しています。Snowballアルゴリズムを見てみましょう。

### Parameters-Parameters-JP-JP-J

* _n_: 参加者数
* _k_ \(sample size\): 1-_n_の間
* α \(quorum size\): 1-_k_の間
* β \(discences-JP): >= 1

### アルゴリズム

```text
preference := pizza
consecutiveSuccesses := 0
while not decided:
  ask k random people their preference
  if >= α give the same response:
    preference := response with >= α
    if preference == old preference:
      consecutiveSuccesses++
    else:
      consecutiveSuccesses = 1
  else:
    consecutiveSuccesses = 0
  if consecutiveSuccesses > β:
    decide(preference)
```

### アルゴリズム説明

誰もがピザやバーベキューを好む。誰かが決まるまで_、__k_ people \(sample size\) をクエリーし、何を望むのかを尋ねる。α以上の人が同じ応答を出すと、その応答は新しい好みとして採用されます。αを_クォーラムサイズ_と呼びます。新しい環境設定が古い環境設定と同じ場合、`successes`カウンターが増加します。新しい設定が異なる場合、古い設定では、`successes` は `1` に反する。 応答がクォーラム \(同じ応答\ のαの過半数) を取得しない場合、`successes` カウンタは `0` に設定されます。

全員が同じ応答β回数についてのクォーラムが行われるまでこれを繰り返します。もしある人がピザを決定した場合、プロトコルに従うすべての人が最終的にピザを決定します。

ランダムサンプリングによって生じる好みのランダムな変更により、1つの選択肢のネットワーク環境を引き起こし、その選択肢のネットワーク環境をより多くのネットワーク環境に設定し、ノードが決定できるようになります。

--素晴らしいビジュアル化については、Ava Labsの共同創立者Ted Yinの[デモ](https://tedyin.com/archive/snow-bft-demo/#/snow)をご覧ください。{% endhint %}

この例では、ピザとバーベキューの両方の選択肢がありますが、Snowballは多くの選択肢を持つ意思決定に合意を得るために適応することができます。

LivenessおよびSafety thresholdsはパラメーター化可能です。Quorumの大きさに加えて、αは増加し、安全閾値は増加し、Livenessの閾値は減少します。これはネットワークはより多くのビザンチン \(意図的に誤り、悪意のある\)ノードを許容し、安全なままであることを意味します。つまり、すべてのノードは、何かが受け入れられても拒否されるかどうかに合意します。Liveness thresholdは、プロトコルが進行することができない前に許容できる悪意のある参加者の数です。

これらの値は、定数であるAvalanche Networkでは非常に小さくなっています。_k_は`20です。` ノードがノードに意見を聞くと、ネットワーク全体から`20`ノードしかクエリできません。quorum size αは`14です。`したがって`、`14個以上のノードが同じ応答を与えると、その応答はクエリーノードの好みに採用されます。決定閾値 β は `20 です。``ノード`は 20 回のクォーラム \(α majority\) 応答を受けた後、選択を決定します。

N-JPはN-JPに加え_、N_-JPにN-JPにNネットワーク内の参加者数に関係なく、送信されたコンセンサスメッセージの数は同じままです。なぜなら、特定のクエリーでは、ネットワークに何千ものノードが存在する場合でも、ノードは`20`ノードしかクエリーしないからです。

## **JavaScript********-JP-JP-**

では、DAG または Directed Acyclic Graph というデータ構造を紹介します。DAGは意思決定の**一部順序**を与えます。例えば、この図でDAGをチェックアウトします。

![Basic DAG-JP](../../.gitbook/assets/cons-01-Frame16.png)

**a****** **は b 前 b です。b** **は d** 前 b は d 前 b は **e** **前 b は** e 前 e 前 といえばいい**です。**しかし、これは部分的な順序であるため、一部の要素では順序は定義されていませ**ん**。例えば、**b** と c は **a** からなるが、**b** **が c の**前後か後**に**あるかどうかは考えられない。

DAG 関連の 2 つの追加の概念は**、祖先**と**子孫**です。Ancestors は、DAG 内の任意のノードで、線を描画できるようにします。例えば、**d** の祖先は **a**, **b**, and **c である。****** **e** の祖先は a, **c である。****a** の子孫は **b**, **c**, **d**, **e** である.**b** **の**子孫は d である.

例えば、BitcoinとEthereumの両方には、すべてのブロックに1人の親と1人の子どもが1つある線形チェーンがあります。AvalancheはDAGを使用してデータを線形鎖ではなく保存します。DAGの各要素には複数の親がいるかもしれません。DAG の親子関係は、アプリケーションレベルの依存関係を意味するものではありません。

コンセンサスプロトコルでは、ゲームの名前は、DAGに**矛盾するトランザクション**を組み込むことを防ぐことです。コンフリクトはアプリケーション定義です。異なるアプリケーションには、2つのトランザクションが競合する場合の意味について異なる概念があります。例えば、P2P決済システムでは、同じUTXO [\(Unspeed Transaction Output\)](https://en.wikipedia.org/wiki/Unspent_transaction_output)を消費するトランザクションが競合します。Avalancheでは、すべてのトランザクションは競合トランザクションから成る**競合セット**に属します。DAG にコンフリクトセット内のトランザクションは 1 つだけ含まれます。各ノードは、競合セットで1つのトランザクションを**好み**ます。

## 作業例

Avalancheネットワークが次のパラメータで動作しているとします。サンプルサイズ_k_は`4です`。 Quorumサイズαは`3`です。 連続した成功数βは`4`です。

![作業例1](../../.gitbook/assets/cons-02-Consensus_Doc_txY.png)

Nodeは新しいトランザクション**Y**について調べます。これは、上記のパラメータに基づいてネットワークをクエリします。_k_ \(`4`\) バリデーターに問い合わせて、「このトランザクションはお好みですか?」と尋ねます。返事を返します-3人は**yes** と、1人は**no**と言います。quorum size, α, `3`は3ですのでyesの応答のα magazine \(quorum\)があります。JavaScript-JP-JP-

![作業例2](../../.gitbook/assets/cons-03-Consensus_Doc_txY-6.png)

トランザクションのα-massy 応答を取得した場合、そのトランザクションに**chit**を与えます。これは、「このトランザクションについてネットワークに問い合わせたとき、α-massy では、彼らがそれを好むと言いました」という真偽値です。JavaScript-JP-JP-

**また、自信**の概念もあります。これは、頂点のchitとその子孫のchitsの和を加えた和です。例えば、トランザクション**V**にはchitがあります。また、chitを持つ3人の子孫もいますので、その信頼性は`3`から`4`に増加します。同様に、トランザクション**W**と**X**は両方ともchitを持ち、両方ともchitを持つ子孫を持ち、それらは両方ともchitを持つ子孫を持ちます。それにより、それぞれに信頼性があります `2`.トランザクションYは信頼性`1`を持っています。

JPS-JPS**-**これは、トランザクション、またはトランザクションの子孫が、成功したα magazine クエリーレスポンスを受け取った回数です。これまではトランザクションVは`3`つの連続した成功を収め、それ自身とその2つの子どもたちが2つで、今ではトランザクションYで`4`つの連続した成功を収めています。

![作業例3](../../.gitbook/assets/cons-04-Consensus_Doc_txY-2.png)

この例では、受諾しきい値のβは`4`です。トランザクションVは4回連続し`た`成功を収めているので**、受け入れ**られます。このノードは、他のすべての正しいノードが最終的にこのトランザクションを受け入れることを確実にします。

![作業例4](../../.gitbook/assets/cons-05-Consensus_Doc_txY-3.png)

これで、**トランザクションY'**がトランザクションYと衝突するトランザクションY'についてノードが学習し_た_とします。これは、be-JP \(`4`\)バリデータと同じ手順に従い、トランザクションY'を好むかどうかを尋ねます。JP-JP-今回はα-massy-pressionがなく、DAGはそれに応じて更新されます。

![作業例5](../../.gitbook/assets/cons-06-Consensus_Doc_txY-4.png)

J-PLAN-JP-JP-Transaction Y'はchitを取得しません。なぜなら、α marjitan-jpに反応しません。Chitがなく、子孫がいないため、confidence `0` です。これは、前のクエリではαの多数応答が得られなかったため、`0`回連続で成功しています。Wの連続した成功カウンターは2から`0`に達し`ます`。その信頼性は`まだ2`です。

ノードが指定されたトランザクションを好むかどうかを尋ねられたとき、トランザクションがトランザクションのコンフリクトセットでトランザクションの信頼性が最も高い場合、yesに返信します。この例では、トランザクションYは信頼性`1`を持ち、トランザクションYは信頼性`0`を持ち、トランザクションYはトランザクションYはトランザクションYよりも信頼性0を持ちます。

![作業例6](../../.gitbook/assets/cons-07-Consensus_Doc_txY-1.png)

これで、ノードは新しいトランザクション**Z**について学び、以前と同じことを行います。_k_ノードに問い合わせ、αの多数応答を取り戻し、DAGを更新します。

![作業例7](../../.gitbook/assets/cons-08-Consensus_Doc_txY-5.png)

Transaction Zはchitを取得します。また`、1`と`1`の連続成功の自信を持っています。処理の祖母も更新されます。トランザクションには`4`つの連続した成功がないため、祖先は受け入れられません。

## Vertices について

この点で説明したすべては、[Avalancheホワイトペーパー](https://assets-global.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf)でどのように説明されているかです。Ava Labs \(AvalancheGo\)によるAvalancheコンセンサスプロトコルの実装には、レイテンシーとスループットのためのいくつかの最適化があります。最も重要な最適化は**、頂点**の使用です。頂点は、線形ブロックチェーン内のブロックのようにあります。JavaScript-JavaScript-JavaScript-JavaScript-JavaScript-JavaScript-JavaScriVerticesではトランザクションを1つずつではなくグループで一括して投票できます。DAG は頂点で構成され、プロトコルは上記の方法と非常に似ています。

ノードがvertexに対する投票を受け取った場合、それはvertex内のすべてのトランザクションに対する投票としてカウントされ、投票は一時的に上方に適用されます。頂点は、その中にあるすべてのトランザクションが受け入れられるときに受け入れられます。頂点に拒否されたトランザクションが含まれている場合、それは拒否され、その子孫すべてが拒否されます。vertex が拒否された場合、有効なトランザクションは、rejected vertex の子ではない新しい vertex に再発行されます。新しい頂点は、優先頂点に追加されます。

## JP-JP-

Avalancheコンセンサスは、安全閾値まで確率的に安全です。つまり、正しいノードが別の正しいノードが拒否するトランザクションを受け入れる確率は、システムパラメータを調整することによって任意に低くすることができる。Nakamotoコンセンサスプロトコル \(BitcoinやEthereumで使用されるように)では、ブロックはチェーンに含まれますが、その後、削除され、正規チェーンには終わらないようにします。これはトランザクション決済の時間を1時間待ちます。Avalancheでは、受諾/拒絶は**最終的かつ不可逆的で**あり、数秒かかります。

## 最適化

ノードが「この頂点を好むか？」と尋ねるのは効率的ではありません。JavaScript-JavaScript-JavaScript-JavaScript-JavaScript-JavaScript-JavaScriAva Labsの実装では、クエリー中にノードが尋ねる「この頂点が存在すると、どの頂点がどの頂点が望ましいか」。yes/noのバイナリを戻す代わりに、ノードは他のノードの好ましい頂点集合を受け取ります。

Nodes は新しいトランザクションを聞いたときだけクエリーするだけではありません。彼らは、善意の頂点処理がないまで繰り返しクエリします。善意の頂点とは、競合がないものです。

ノードは、投票結果を登録する前に、すべての_k_クエリレスポンスを取得するまで待つ必要はありません。もしトランザクションがαの過半数を得ることができない場合、レスポンスを残りの部分に待つ必要はありません。

## バリデータ

Avalancheネットワーク上でバリデーターになることができれば、それは問題になります。悪意のあるアクターは、ノードが悪く動作し、安全性やライブネス障害を引き起こす可能性があります。コンセンサスの一部として照会されるノードであるバリデータは、ネットワークに影響を与えます。彼らはこの種の投票詰めを防ぐために、その影響を現実の世界の価値で支払わなければなりません。このような現実の価値を活用して、ネットワーク上の影響力を買うという考え方は、Proof of Stakeと呼ばれています。

バリデータになるには、ノードは \(stake\) 何か貴重な \(**AVAX**\) を**結びつけ**なければなりません。AVAX ノード結合が多いほど、そのノードは他のノードから照会されることが多いです。ノードがネットワークをサンプルするときは、一貫してランダムではありません。むしろ、それはステーク量によって重み付けられます。ノードは、バリデーターとしてのインセンティブを受けるため、バリデーターは、バリデーターとしてのインセンティブを受けることができます。

Avalancheにはスラッシュがありません。ノードが正しく動作しない場合、応答を正しく返すか、または応答しないかどうか、または全く返すかなど、検証中にノードがうまく動作しない場合、そのステークはまったく返されますが、報酬なしです。結合されたAVAXの十分な部分が正しいノードで保持されている限り、ネットワークは安全であり、好意的なトランザクションのために生きています。

## ビッグアイデア

Avalancheの2つの大きなアイデアは**、サブサンプリング**と**トランジティブ投票**です。Subsamplingには、メッセージオーバーヘッドが少なくなります。20 個のバリデーターや 2000 個のバリデーターが存在するかどうかは問題ありません。クエリー中にノードが送信するコンセンサスメッセージの数は一定です。

![作業例8](../../.gitbook/assets/cons-09-Consensus_Doc_txY-7.png)

トランザクションのスループットに役立つ、頂点への投票は、すべての祖先に対する投票である。各投票は1票で多数です。例えば、上記の図では、ノードが**頂点D**に投票した場合、それはすべての祖先に対する投票を意味します。**D**に対する投票はまた、**A**、**B**、**C**に対する投票です。

## Loose Ends - 終了

トランザクションは、[AvalancheGo](https://github.com/ava-labs/avalanchego)フルノードでAPIを呼び出すか、[AvalancheJS](https://github.com/ava-labs/avalanchejs)などのライブラリを使用してそれらを作成するユーザーによって作成されます。頂点は、ノードが着信トランザクションを一緒にバッチする場合、または拒否された頂点からの受け入れられたトランザクションが再発行され、DAGに追加されたときに作成されます。vertexの両親は、DAGの先端にある競合のないノードである善良なフロンティアから選択されます。ノードが拒否される可能性が高いため、 virtuous vertical 上に構築することが重要です。なぜなら、ノードが拒否される可能性が高いからです。

## その他の観察

競合トランザクションが生きていることは保証されません。これは実際に問題ではありません。トランザクションをライブにしたい場合は、競合するトランザクションを発行すべきではありません。

Avalancheは線形鎖でも動作します。プロトコルは大抵上記と同じですが、各頂点には親が1つしかありません。これは頂点の総順序を示す。これは、スマートコントラクトなどのトランザクションが別のトランザクションの前に来たかどうかを知る必要がある特定のアプリケーションに便利です。Snowman は、Ava Labs がリニアチェーンのためのAvalancheコンセンサスプロトコルの実装の名前です。

未定トランザクションがない場合、Avalancheコンセンサスプロトコルが_停止します。_つまり、仕事がなければ何もありません。Avalancheは、ノードが常に仕事をする必要があるProof-of-workよりも持続可能なものです。

アバランシェにはリーダーがいない。どのノードでもトランザクションを提案でき、AVAXをステークしたノードはすべてのトランザクションに投票できるため、ネットワークをより堅牢で分散型化しています。

## なぜ私たちは気にかけるのですか？

Avalancheは一般的なコンセンサスエンジンです。どのようなアプリケーションが上に置かれているかは関係ありません。このプロトコルにより、アプリケーションレイヤーをコンセンサスレイヤーからデカップリングできます。AvalancheでDappを構築する場合は、コンフリクトの定義方法やトランザクション内のものなど、いくつかのことを定義する必要があります。ノードがどのように合意に達するか心配する必要はありません。コンセンサスプロトコルはブラックボックスで、何かを入れて、受け入れられたり拒否されたり戻ってきます。

AvalancheはP2P決済ネットワークだけでなく、あらゆるアプリケーションに使用できます。AvalancheのPrimary Networkには、Ethereum Virtual Machineのインスタンスがあり、既存のEthereum Dappsおよび開発ツールと後方互換性があります。EthereumコンセンサスプロトコルがAvalancheコンセンサスに置き換えられており、ブロックレイテンシーとより高いスループットを可能にしています。

Avalancheは非常にパフォーマンス的です。1-2秒の受諾レイテンシで、1秒間に何千ものトランザクションを処理できます。

## JavaScript-JP-JP-

Avalancheコンセンサスは分散システムにおける急進的なブレークスルーである。これは、以前から来た古典的および中本のコンセンサスプロトコルと同じくらい大きな飛躍を表しています。これで、どのように機能するかについてよりよく理解できるようになりましたら、Avalancheでゲーム変更のDappsや金融商品を構築するための他の[ドキュメント](https://docs.avax.network)をチェックしてください。

