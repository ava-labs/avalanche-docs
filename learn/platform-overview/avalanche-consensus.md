---
description: Avalancheコンセンサスプロトコルを深く知る
---

# Avalancheコンセンサス

コンセンサスとは、複数のコンピューターに、決定の合意に至らせるための作業です。コンピュータは、コンセンサスプロトコルと呼ばれる一連のステップに従ってコンセンサスに至ることができます。Avalancheは、拡張性があり安定した分散型の新しいコンセンサスプロトコルです。Avalancheは、待ち時間が短く、高いスループットを提供します。エネルギー効率が高く、特別なコンピュータハードウェアは必要ありません。敵対的な場面でもうまく動作し、「51%攻撃」に対して耐性を持ちます。このドキュメントでは、Avalancheコンセンサスプロトコルについて説明します。ホワイトペーパーは[こちら](https://www.avalabs.org/whitepapers)をご覧ください。

## 直感

まずこのプロトコルについての少し直感を発達させていきましょう。部屋にいっぱい人が集まってランチに何を食べるか意見をまとめようとしていると想像してください。ピザかバーベキューの二者択をするとします。最初は、ピザを選ぶ人もいるでしょうし、バーベキューを選ぶ人もいるでしょう。いずれにせよ最終的には、全員にとってのゴールは**コンセンサス**に至ることです。

みんながそれぞれ部屋にいる人のうちランダムに選んだグループに対して、ランチにどちらを選ぶかたずねます。そして、その半数を超える人がピザと答えると、質問をした人は考えます。「そうか、ピザに傾倒しているようだな。では私もピザを選ぼう。」つまり、皆が多数派の_選択_に適応するのです。同様に、多数がバーベキューというと、人は選択をバーベキューに適応させます。

全員がこのプロセスを繰り返します。このプロセスを一巡するごとに、より多くの人が同じ選択をするようになります。あるオプションを選ぶ人が多いほど、人は多数派の意見を受けて、選択を合わせようとしがちになるからです。プロセスが十分に繰り返されたのち、コンセンサスに達し、全員が選択する、一つのオプションに決定します。

## Snowball

上記の直感は、Avalancheコンセンサスのブロックを構築する、Snowballアルゴリズムの概要を示しています。Snowballアルゴリズムを見てみましょう。

### パラメータ

* _n_：参加者の数
* _k_（サンプルサイズ）：1から_n_の間
* α（クォーラムサイズ）：1から_k_の間
* β（決定しきい値）：>= 1

### アルゴリズム

```text
preference := pizza
consecutiveSuccesses := 0
while not decided:
  ask k random people their preference
  if >= α give the same response:
    preference := response with >= α
    if preference == old preference:
      consecutiveSuccesses++
    else:
      consecutiveSuccesses = 1
  else:
    consecutiveSuccesses = 0
  if consecutiveSuccesses > β:
    decide(preference)
```

### アルゴリズムの説明

誰もが最初、ピザかバーベキューかを選択します。誰かが_決定する_まで、（サンプルサイズである）_k_人に質問し、どちらを選択するか尋ねます。α人以上の人が同じ回答をした場合、その回答が新しい選択として採用されます。αは_定足数サイズ_と呼ばれます。新しい選択が、それまでの選択と同じ場合、`consecutiveSuccesses`カウンタはインクリメントされます。新しい選択が、それまでの選択と異なる場合は、`consecutiveSucccesses`カウンタは`1`になります。答えがクォーラム（同じ回答がαの数を満たす）に達すると、`consecutiveSuccesses`カウンタは`0`になります。

同じレスポンスがつづけてβ回、クォーラムが得られるまで全員がこの動作を繰り返します。一人がピザに決定すると、このプロトコルに従うほかのすべての人も最終的にピザに決定することになります。

ランダムサンプリングによって引き起こされる選択のランダムな変化によりネットワークが一つの選択を行います。これにより、より多くのネットワークが同じ選択をするようになります。選択が不可逆的になり、ノードが決定できるようになるまで繰り返されます。

{% hint style="info" %}映像で確認いただくには、Ava Labの共同創業者、Ted Yinの[デモ](https://tedyin.com/archive/snow-bft-demo/#/snow)をご覧ください。{% endhint %}

この例では、ピザとバーベキューの二者択一でした。しかしSnowballは、多くの選択肢でも決定のコンセンサスに至るよう適応できます。

ライブネスと安全性のしきい値はパラメータ化が可能です。クォーラムサイズ、αが増加すると、安全性しきい値が上がり、ライブネスしきい値は低下します。つまり、ネットワークがより多くのビザンチン（悪意を持ち、意図的に間違う）ノードを許容し、安全な状態を維持する、つまり最終的にすべてのノードが、受け入れるか拒否するかで合意に至るということです。ライブネスのしきい値は、プロトコルが実行不可能になるまでに許容可能な悪意ある参加者の数です。

これらの値は一定であり、Avalancheネットワーク上では非常に小さいものです。サンプルサイズ_k_は、`20`です。従って、あるノードがノードグループに意見を聞く際、ネットワーク全体の中から`20`のノードのみに問い合わせることになります。クォーラムサイズαは、`14`です。従って、`14`以上のノードが同じ回答をする場合、その回答はクエリを出しているノードの選択として適応されます。決定閾値βは、`20`です。`20`連続したクォーラム（同じ回答がαの数を満たす）の回答を受け取ったのちに、ノードは選択を決定します。

Snowballは、ネットワーク上のノードの数、_n_が増えるため、高い拡張性を持ちます。ネットワーク上での参加者の数にかかわらず、送られるコンセンサスメッセージの数は同じです。というのは、ネットワーク上の何千ものノードがあっても、ノードは、一つの質問に対し、`20`個のノードにしか質問しないためです。

## DAGs \(**D**irected **A**cyclic **G**raphs（有向非巡回グラフ）\)

では、DAGあるいは有向非巡回グラフと呼ばれるデータ構造をご紹介しましょう。DAGは、決定にかかわる**一部の秩序**を提供します。例えば、この図形のDAGをご覧ください。

![基本DAG](../../.gitbook/assets/cons-01-Frame16.png)

**a**は**b**の前にあります。**b**は**d**の前にあります。**c**は**e**の前にあります。推移的に、**a**は**e**の前に来ると言うことができます。ただし、これは半順序であるため、一部の要素では、順序が定義されていません。例えば、**b**と**c**の両方が**a**の後にきていますが、**b**が**c**の先か後かには言及がありません。

2つの追加のDAGに関連するコンセプトは、**祖先**と**子孫**です。祖先は、上方向に線を引くDAG上のすべてのノードです。例えば、**d**の祖先は**a**、**b**、**c**です。**e**の祖先は**a**、**c**です。子孫は祖先の反対です。**a**の子孫は**b**、**c**、**d**、**e**であり、**b**の子孫は**d**です。

例えば、ビットコインとEthereumは両方とも、すべてのブロックに一人の親と一人の子がいるリニアチェーンを持ちます。AvalancheはDAGを使用することで、データをリニアチェーンではない形で保存します。DAGの各要素は複数の親を持ちえます。DAGにおける親子関係は、アプリケーションレベルの依存を意味するものではありません。

コンセンサスプロトコルで肝心なのは、**競合するトランザクション**がDAGに含まれることを防止することです。競合はアプリケーションで定義されます。異なるアプリケーションでは、2つのトランザクションが競合することの意味について異なる解釈をもちえます。例えば、P2P支払いシステムでは、同じUTXO（[Unspent Transaction Output（未使用トランザクションアプトプット）](https://en.wikipedia.org/wiki/Unspent_transaction_output)\)を消費するトランザクションが競合する場合があります。Avalancheでは、すべてのトランザクションが、競合するトランザクションからなる**競合セット**に属します。競合セットのうちただ1つのトランザクションだけがDAGに含まれることができます。各ノードは競合セットの中から1つのトランザクションを**選択します**。

## 動作例

次のパラメータで実行されているAvalancheネットワークがあるとします。サンプルサイズ_k_は、`4`です。クォーラムサイズαは、`3`です。連続した成功の数βは、`4`です。

![動作例1](../../.gitbook/assets/cons-02-Consensus_Doc_txY.png)

ノードは、新しいトランザクション**Y**を発見し、上記のパラメータに基づいてネットワークに問い合わせます。_k_\(`4`\)個のバリデータに問い合わせ、「このトランザクションを選択しますか？」と尋ねます。その結果、3人が**はい**、1人が**いいえ**という回答が返ってきました。定足数αは`3`で、そのため「はい」という回答がα個の多数（定足数）になります。ここで、ノードはDAGを更新します。

![動作例2](../../.gitbook/assets/cons-03-Consensus_Doc_txY-6.png)

ノードがあるトランザクションについてαの数を満たした場合、トランザクションに、「私はネットワークにこのトランザクションについて質問し、αを満たす数がこれを選択すると答えました。」というブール代数である**chit**（メモ）を渡します。この例では、トランザクション**Y**は、chit（メモ）を取得します。

**confidence**（信頼）の概念もあります。これは、バーテックスのchit（メモ）の合計に、子孫のchit（メモ）の合計を加えたものです。例えば、トランザクション**V**は、chit（メモ）を持っています。これには、chit（メモ）を持っている3つの子孫があります。そのため、confidence（信頼）は`3`から`4`に増加します。同様に、トランザクション**W**と**X**の両方がchit（メモ）を持ち、両方ともchit（メモ）を持った子孫を持っています。そのため、これらはそれぞれconfidence（信頼）を持っているのです`2`。トランザクション**Y**はConfidence（信頼）を持っています`1`。

**Consecutive successes**（連続した成功）は、Snowball上と同じです。これが、トランザクションあるいはトランザクションの子孫がαに達する回答を得るのに成功した回数です。トランザクション**V**は、以前はそれ自体とその2つの子供で`3`、のconsecutive success（連続した成功）を持っていましたが、今はトランザクション**Y**とあわせてのconsecutive success（連続`4`した成功）を持っています。これは、トランザクション**W**と**X**でも同様です。

![動作例3](../../.gitbook/assets/cons-04-Consensus_Doc_txY-2.png)

この例では、受け入れしきい値βは、`4`です。トランザクション**V**は、`4`のconsecutive suceess（連続した成功）を得たため、**受け入れ**られました。このノードは、ほかのすべての正しいノードが最終的にこのトランザクションを受け入れることを確信しています。

![動作例4](../../.gitbook/assets/cons-05-Consensus_Doc_txY-3.png)

さて、トランザクション**Y**と競合するトランザクション**Y'**についてノードが学んだとします。これまでと同様のステップに従い、_k_（`4`）バリデータをサブサンプルし、トランザクション**Y'**を選択するかどうか尋ねます。この場合、これらのうちの2つが、**Y'**を選択するといい、別の2つが**Y'**を選択しないといいます。この時は、αに達したという回答は得られず、DAGはそれに応じて更新されます。

![動作例5](../../.gitbook/assets/cons-06-Consensus_Doc_txY-4.png)

トランザクション**Y**と**Y'**は競合セットになっています。そのうち1つだけが最終的に受け入れられます。トランザクション**Y'**は、αに達したという回答を得られなかったため、chit（メモ）が得られません。これは、`0`のconfidence（信頼）を持ちます。というのも、chit（メモ）を持たず、chit（メモ）を持つ子孫もいないからです。これは、`0`のconsecutive success（連続した成功）を持ちます。というのも、以前の問い合わせにα回の回答を得られなかったからです。トランザクション**W**のconsecutive success（連続した成功）カウンタは、`2`から`0`になります。このconfidence（信頼）はまだ`2`です。

ノードは、与えられたトランザクションを選択するかどうかを尋ねられた時、トランザクションがトランザクションのコンフリクトセットにあるほかのトランザクションよりも高いconfidence（信頼）を持っていれば、はい、と答えます。この例では、トランザクション**Y**は、Confidence（信頼）`1`を持ち、トランザクション**Y'**は、confidence（信頼）`0`を持ちます。従ってノードはトランザクション**Y'**ではなくトランザクション**Y**を選択します。

![動作例6](../../.gitbook/assets/cons-07-Consensus_Doc_txY-1.png)

これで、ノードは新しいトランザクション**Z**について学びました。そして、以前と同様のことを行います。_k_ノードにクエリを送り、αに達する回答を得、DAGを更新します。

![動作例7](../../.gitbook/assets/cons-08-Consensus_Doc_txY-5.png)

トランザクション**Z**はchit（メモ）を取得します。また、`1`のconfidence（信頼）`1`とconsecutive success（連続した成功）を持っています。処理された祖先も更新されます。いずれのトランザクションも`4`consecutive success（連続した成功）を得られませんでした。そのためどの祖先も受け入れられません。

## Vertices（バーテックス）

[Avalancheホワイトペーパー](https://assets-global.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf)でのAvalancheの説明が、このポイントで話されているすべてです。Ava Labsによる（すなわちAvalancheGo上での）Avalancheコンセンサスプロトコルの実行は、待ち時間とスループットの最適化をもたらします。最も重要な最適化は、「**vertices**（バーテックス）」の使用です。バーテックスは、リニアブロックチェーンのブロックのようなものです。親のハッシュを含み、トランザクションのリストを含みます。バーテックスは、トランザクションをバッチ化し、一つ一つ処理するのではなくグループで投票することを可能にします。DAGは、バーテックスからなり、プロトコルは、上記の説明と大変似た形で機能します。

ノードがバーテックスに対する投票を受け取った場合、バーテックス内のすべてのトランザクションに対する投票としてカウントされ、投票は推移的に上方向に適用されます。バーテックスは、その中にあるすべてのトランザクションが受け入れられたときに受け入れられます。バーテックスが拒否されたトランザクションを含む場合は、そのバーテックスは拒否され、すべての子孫も拒否されます。バーテックスが拒否されると、有効なトランザクションはすべて、拒否されたバーテックスの子供ではない新しいバーテックスに再発行されます。新しいバーテックスが、選択されたバーテックスに追加されます。

## ファイナリティ

Avalancheコンセンサスは、安全性しきい値までは確率論的に安全です。つまり、正しいノードが別の正しいノードが拒否したトランザクションを受け入れる確率は、システムのパラメータを調整することで任意に低く抑えることができます。（例えばビットコインやEthereumで使用されている）ナカモトコンセンサスプロトコルでは、ブロックはチェーンに含まれていて、しかしその後削除され、canonicalチェーンでは終了しないこともあります。つまり、トランザクションの決済に1時間も待つということです。Avalancheでは、受け入れ/拒否は**最終的かつ不可逆的**であり、数秒で処理されます。

## 最適化

バリデータに問い合わせる場合、ノードが「このバーテックスの方がいいですか？」と尋ねるだけでは効率的ではありません。Ava Labsの実行では、ノードがクエリ中に「このバーテックスが存在しています。どのバーテックスを選びますか？」と尋ねます。はいかいいえの二者択で返答するかわりに、ノードは、他のノードが選択したバーテックスセットを受け取ります。

ノードは、新しいトランザクションについてのみにクエリを出すのではありません。好ましいバーテックスのプロセスがこれ以上行われなくなるまでクエリを繰り返します。好ましいバーテックスとは、競合がないものをいいます。

ノードは、投票の結果を登録する前に_k_クエリレスポンスをすべて得るまで待つ必要はありません。いずれのトランザクションもα回の回答を得られない場合でも、残りのレスポンスを待つ必要はないのです。

## バリデーター

Avalancheネットワーク上のバリデータに自由になれるとすれば問題です。というのも悪意ある参加者が、とても頻繁にクエリを受ける非常に多くのノードを起動させることができるからです。悪意ある参加者は、ノードを問題を起こすように動作させ、安全性あるいはライブリネスの障害を引き起こし得ます。バリデーター、コンセンサスの一部としてクエリを受けるノードは、ネットワーク全体に影響を与えます。このような票の水増しを防ぐために、その影響力に対する代金を現実世界の価値で支払わねばなりません。ネットワークでの影響力を購入するために、現実世界の価値を使用するというアイデアは、プルーフ・オブ・ステークと呼ばれています。

バリデータになるためには、ノードは、価値のあるもの（**AVAX**）と**結び付け**（ステーク）をしなくてはなりません。ノードがより多くのAVAXと結びつくほど、そのノードは、他のノードからより頻繁にクエリを受け取ることになります。ノードがネットワークをサンプリングするときに、一様に無作為に行われるわけではありません。むしろ、ステーク量により重みづけが行われます。ノードにはバリデーターになるインセンティブが与えられます。なぜなら、ノードがバリデートしている間、十分に正しく、適切に応答していれば報酬が与えられるからです。

Avalancheにはスラッシュはありません。誤った回答を与えたり、まったく回答を返さないなど、バリデート中にノードが正しく動作しない場合、そのステークはそれでもすべて返されますが、報酬は得られません。結び付けられているAVAXの十分な量が正しいノードによって保持されている限り、ネットワークは安全であり、好ましいトランザクションとして活動しつづけます。

## 大きなアイデア

Avalancheの2大アイデアは、**サブサンプリング**と**推移的投票**です。サブサンプリングはメッセージのオーバヘッドを低く抑えます。20のバリデータであれ、2,000のバリデータであれ関係ありません。ノードがクエリ中に送るコンセンサスメッセージの数は一定です。

![動作例8](../../.gitbook/assets/cons-09-Consensus_Doc_txY-7.png)

推移的な投票、そこではバーテックスのための投票は、すべての祖先のための投票となるのですが、トランザクションスループットで有用です。各投票では、多くが一つのものに投票します。例えば、上の図では、ノードがバーテックス**D**への投票を得てるならば、それは、そのすべての祖先への投票であることを意味します。**D**のための投票は、**A**、**B**、**C**のための投票でもあるのです。

## ルースエンド

トランザクションは[AvalancheGo](https://github.com/ava-labs/avalanchego)のフルノード上のAPIを呼び出すか、[AvalancheJS](https://github.com/ava-labs/avalanchejs)などのライブラリを使って作成するユーザーによって作成されます。バーテックスは、ノードが入ってくるトランザクションをあわせてバッチするときや、拒否されたバーテックスから受け入れられたトランザクションが再発行され、DAGに追加される際に作成されます。バーテックスの親は、競合のないDAGの先端にあるノードである好ましいフロンティアから選ばれます。好ましいバーテックス上に構築することが重要です。なぜなら好ましくないバーテックス上に構築すれば、ノードが拒否される可能性が高くなり、つまり、その祖先も拒否される可能性が高くなり、あまり前に進めなくなるからです。

## その他の状況

競合するトランザクションがライブであることは保証されません。しかしこれは実際には問題になりません。なぜなら、あなたのトランザクションがライブでありたいと思うなら、競合するトランザクションを発行すべきではないからです。

Avalancheはリニアチェーンにも機能します。プロトコルは上記とほぼ同じですが、各バーテックスには親が1つしかありません。このことによりバーテックスの全体の順序が与えられます。これは、スマートコントラクトなどで、トランザクションが別のトランザクションの前に来るのかどうかを知っておく必要がある特定のアプリケーションで有用です。Snowmanは、リニアチェーンのためのAva LabsのAvalancheコンセンサスプロトコルの実装の名前です。

未決定のトランザクションがない場合、Avalancheコンセンサスプロトコルは_静止します_。つまり、やるべき仕事がなくなると何も行いません。Avalancheは、ノードが絶えず動作しておく必要があるプルーフ・オブ・ワークよりも持続可能性が高いのです。

Avalancheにはリーダーはいません。いかなるノードもトランザクションを提案することができ、ステークされたAVAXをもついかなるノードもすべてのトランザクションに投票できます。これにより、ネットワークはより安定し、分散化されます。

## なぜ注意を払う必要があるのですか？

Avalancheは一般的なコンセンサスエンジンです。その上にどんな種類のアプリケーションを乗せるかは関係ありません。このプロトコルでは、アプリケーションレイヤーとコンセンサスレイヤーを切り離すことができます。自律分散型アプリケーションをAvalanche上で構築する場合、いくつかのことを定義する必要があるだけです。競合をどのように定義するか、トランザクションになにを含めるかということなどです。ノードがどのように合意に達するかについて心配する必要はありません。コンセンサスプロトコルは、そこに何かを入れ、受け入れられたか拒否されたかのどちらかが返ってくるブラックボックスです。

Avalancheは、P2P支払いネットワークだけでなく、あらゆる種類のアプリケーションに使用することができます。AvalancheのPrimary Networkには、既存のEthereumDappsや開発ツールとさかのぼって互換性のあるEthereum仮想マシンのインスタンスがあります。Ethereumのコンセンサスプロトコルは、Avalancheコンセンサスで置き換えられ、ブロックの遅延がより低く抑えられ、スループットがより高くなりました。

Avalancheは非常に高いパフォーマンスを誇ります。1〜2秒の受け入れ遅延で、毎秒何千ものトランザクションを処理することができるのです。

## まとめ

Avalancheのコンセンサスは、分散システムにおける画期的なブレークスルーです。このプロトコルは、それ以前の古典的なコンセンサスプロトコルやNakamotoのコンセンサスプロトコルと同じくらい大きな飛躍を遂げています。この仕組みを理解した上で、Avalancheでゲームを変えるDappsや金融商品を構築するための他の[ドキュメント](https://docs.avax.network)をチェックしてみてください。

