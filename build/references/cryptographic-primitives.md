# 暗号プリミティves

[Avalanche](../../#avalanche)は、さまざまな機能のために様々な暗号プリミティブを使用します。このファイルでは、ネットワークやブロックチェーンレイヤーで使用される暗号の種類と種類をまとめてまとめております。

## ネットワークレイヤー内の暗号化

Avalancheは、TLSを使用し、イーブドロップパーからノードとノード間の通信を保護します。TLSは、パブリック鍵暗号の実用性と、シンメトリック鍵暗号の効率性を組み合わせています。その結果、TLSはインターネットコミュニケーションのスタンダードになりました。ほとんどの古典的なコンセンサスプロトコルでは、サードパーティにメッセージを受信することを証明するために、パブリック鍵暗号を採用していますが、新しいSnow\*コンセンサスファミリーではそのような証明は必要ありません。これによりAvalancheは、ステーカー認証にTLSを採用できるようになり、ネットワークメッセージに署名するための高価な公開鍵暗号化の必要性をなくします。

### TLS証明書

Avalancheは、いかなる集中型サードパーティーに頼らず、特に、サードパーティー認証者によって発行された証明書を使用することはありません。エンドポイントを識別するためにネットワーク層内で使用されるすべての証明書は、自己署名され、自己主権アイデンティティレイヤーを作成します。サードパーティは巻き込まれていません。

### TLSアドレス

TLS証明書をプラットフォームチェーンに投稿しないように、証明書は最初にハッシュされます。一貫性のために、Avalancheは、ビットコインで使用されるTLS証明書に同じハッシュ化メカニズムを採用しています。つまり、証明書のDER表現は、sha256でハッシュされ、結果はripemd160でハッシュされ、ステーカーに20バイト識別子が誕生します。

この20バイト識別子は、「NodeID-」で表され、その後データが符号化した[CB58](https://support.avalabs.org/en/articles/4587395-what-is-cb58)文字列で表されます。

## Avalancheバーチャルマシン内の暗号化

`secp256k1`Avalancheバーチャルマシンは、ブロックチェーン上の署名のために、特に楕円曲線暗号化を使用します。

この32バイト識別子は、「PrivateKey-」で表され、その後データが符号化した[文字](https://support.avalabs.org/en/articles/4587395-what-is-cb58)列が続きます。

### Secp256k1アドレス

Avalancheは、スキームへのアドレス指定について、表記的なものではなく、代わりに各ブロックチェーンにアドレスを指定するようにすることを選択します。

X-ChainとP-Chainのアドレスリングスキームは、secp256k1に依存しています。Avalancheは、ビットコインと同様のアプローチに従い、ECDSA公開鍵をハッシュします。公開鍵の33バイト圧縮表現は、1回の期間、sha256でハッシュされます****。その後、ripemd160でハッシュされ、20バイトアドレスになります。

`chainID`Avalancheは、この規約を使用して、上に存在するどのチェーンが指定`chainID-address`します。外部アプリケーションを通じて情報送信を行う際、CB58条約が必要です。

### Bech32

X-ChainとP-Chain上のアドレスは、[BIP 0173](https://en.bitcoin.it/wiki/BIP_0173)に記載された[Bech32](http://support.avalabs.org/en/articles/4587392-what-is-bech32)スタンダードを使用します。Bech32アドレススキームには、4つの部分があります。外観順で

* 人間が読みやすい部分（HRP）。メインネット上でこれはです`avax`。
* `1`HRPがアドレスとエラーコレクションコードから分離する数値。
* 20バイトアドレスを表すベース32エンコードされた文字列。
* 6文字のベース32エンコードされたエラー訂正コード。

さらに、Avalancheアドレスは、上に存在するチェーンのエイリアスに接頭辞が付けられ、その後ダッシュが続きます。たとえば、X-Chainアドレスは、接頭辞として付近があります`X-`。

メインネット、fuji、ローカルネットのためのX-Chain、P-Chain、C-Chain上のアドレスと一致します。有効なAvalancheアドレスは全てこの正規表現と一致しますが、Avalancheアドレス以外の文字列でこの正規表現に一致する場合があります。

```text
^([XPC]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$
```

Avalancheのアドレススキームについて詳しく読む[。](https://support.avalabs.org/en/articles/4596397-what-is-an-address)

### Secp256k1

**`[R || S || V]`****`V`**回復可能な署名は、0または1で、迅速な公開鍵リカバリ可能性を可能にします。署名の不可動性を防ぐために、可能な範囲の下半分でなければなり**`S`**ません。メッセージに署名する前に、sha256を使用してメッセージがハッシュされます。

### Secp256k1例

RickとMortyが、安全な通信チャネルを設定しているとしましょう。Mortyは、新しい公開秘密鍵ペアを作成します。

秘密鍵：`0x98cb077f972feb0481f1d894f272c6a1e3c15e272a1658ff716444f465200070`

公開キー（33バイト圧縮）：`0x02b33c917f2f6103448d7feb42614037d05928433cb25e78f01a825aa829bb3c27`

Rickの無限の知恵のため、Mortyの公開鍵を担当すると信じられないため、Mortyのアドレスのみを求めるのです。Mortyは、SHA256の公開鍵であり、その後のripemd160の命令に従い、アドレスが生成します。

SHA256\(公開鍵\)：`0x28d7670d71667e93ff586f664937f52828e6290068fa2a37782045bffa7b0d2f`

アドレス:`0xe8777f38c88ca153a6fdc25942176d2bf5491b89`

Mortyは、公開鍵は、公共の知識であることが安全であるべきであるため、かなり混乱しています。Rickは、公開鍵をハッシュ化することで、楕円曲線暗号における将来のセキュリティ上の欠陥から秘密鍵所有者を保護するようになります。万が一、暗号が壊れ、秘密鍵が公開鍵から派生できる場合、ユーザーは以前に取引に署名したことのないアドレスに資金を送金することができます。そのため、彼らの資金が攻撃者によって侵害されることを防ぎます。これにより、暗号がクライアント全体でアップグレードされる中にコインの所有者の保護が可能になります。

その後、MortyがRickのバックストーリーを知った後、MortyはRickにメッセージを送ろうとします。Mortyは、Rickが自身からであることを確認できる場合にのみメッセージを読むことを知っています。そのため、彼の秘密鍵でメッセージにサインするサインします。

メッセージ：`0x68656c702049276d207472617070656420696e206120636f6d7075746572`

メッセージハッシュ：`0x912800c29d554fb9cdce579c0abba991165bbbc8bfec9622481d01e0b3e4b7da`

メッセージ署名：`0xb52aa0535c5c48268d843bd65395623d2462016325a86f09420c81f142578e121d11bd368b88ca6de4179a007e6abe0e8d0be1a6a4485def8f9e02957d3d72da01`

Mortyは、二度と見ることはありません。

## 署名されたメッセージ

ビットコインスクリプトフォーマットとイーサリアムフォーマットに基づく相互運用可能な一般的な署名メッセージのための標準です。

```text
sign(sha256(length(prefix) + prefix + length(message) + message))
```

`0x1A`プレフィックスは、プレフィックステキストの長さで`\x1AAvalanche Signed Message:\n`、メッセージサイズ[の整数](serialization-primitives.md#integer)`length(message)`です。

### Gantt プリイメージ仕様

```text
+---------------+-----------+------------------------------+
| prefix        : [26]byte  |                     26 bytes |
+---------------+-----------+------------------------------+
| messageLength : int       |                      4 bytes |
+---------------+-----------+------------------------------+
| message       : []byte    |          size(message) bytes |
+---------------+-----------+------------------------------+
                            |       26 + 4 + size(message) |
                            +------------------------------+
```

### 例

例として、「星にコンセンサスを通じて」というメッセージにサインします。

```text
// prefix size: 26 bytes
0x1a
// prefix: Avalanche Signed Message:\n
0x41 0x76 0x61 0x6c 0x61 0x6e 0x63 0x68 0x65 0x20 0x53 0x69 0x67 0x6e 0x65 0x64 0x20 0x4d 0x65 0x73 0x73 0x61 0x67 0x65 0x3a 0x0a
// msg size: 30 bytes
0x00 0x00 0x00 0x1e
// msg: Through consensus to the stars
54 68 72 6f 75 67 68 20 63 6f 6e 73 65 6e 73 75 73 20 74 6f 20 74 68 65 20 73 74 61 72 73
```

プリイメージでハッシュ、署名した後`sha256`、[cb58](https://support.avalabs.org/en/articles/4587395-what-is-cb58)をエンコードした値を返します： .`4Eb2zAHF4JjZFJmp4usSokTGqq9mEGwVMY2WZzzCmu657SNFZhndsiS8TvL32n3bexd8emUwiXs8XqKjhqzvoRFvghnvSN`[Avalancheウェブウォレット](https://wallet.avax.network/wallet/advanced)を使用した例を以下に示します。

![メッセージ](../../.gitbook/assets/sign-message.png)

## イーサリアムの仮想マシンでの暗号化

Avalancheノードは、完全なイーサリアムバーチャルマシン（EVM）をサポートし、イーサリアムで使用されるすべての暗号構成を正確に複製します。これには、Keccakハッシュ機能や、EVMにおける暗号セキュリティに使用される他のメカニズムが含まれます。

## 他のバーチャルマシンで暗号化

Avalancheは拡張可能なプラットフォームです。そのため、時間の経過とともに、追加の暗号プリミティブをシステムに追加するものと期待しています。

